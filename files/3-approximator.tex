\subsection{A Semantic Operator for AICs}
Recall that in this paper, we only consider normal AICs, i.e., expressions $r$ of the form 
\[ l_1\land \ldots \land l_n \aicrule \alpha\]
where $\alpha = \actof(l_1)^D$ (after renumbering the $l_i$).
For such a rule, we define $\nup(r) = \l_2\land \dots \land l_n$. The intuition is that $\nup(r)$ is the non-updatable part of the body of $r$. 
% As soon as $\nup(r)$ holds, so should $l_1^D$. Indeed, if $l_1$ holds, then $\alpha$ dictates to change its value; if $l_1$ does not hold, the integrity constraint is satisfied. 

Given a fixed database $\db$.
The sets of update actions $\UU$ that are of interest to us are those such that \textbf{(i)} \UU is consistent and \textbf{(ii)} each action in \UU modifies \db. As argued by  \citet{iclp/Cruz-Filipe16}, the set of such sets is isomorphic to $2^{\atoms}$. Hence, from now on, we identify such a set with a subset of $\atoms$ (the atoms whose value is changed by \UU). 
If $a\in \atoms$ and $\db$ is a database, we define $\change a$ to be the update action $\add a$ if $a\in \db$ and $\remove a$ if $a\not \in \db$. 
Thus, in the above identification, a set  of atoms $\bar\UU\subseteq \atoms$ is identified with the set 
\[\UU = \{\change a\mid a \in \bar \UU \}\]
of update actions.
Usually, we omit the bar, and simply write $\UU$ for the subset of \atoms as well. Only in places where the distinction between the two is essential (in technical parts of proofs), we explicitly write $\bar \UU$. 
% In some technical parts of the paper, we often switch between 

Furthermore, we prefer smaller set of updates over lager sets: if a database can be fixed by just having $\{\add a\}$, the set $\{\add a, \add b\}$ is not of interest to us. 
The lattice we are interested in is thus $\langle 2^{\atoms}, \subseteq\rangle$. 
In this lattice, smaller elements correspond to more preferred repairs. 


Now consider a set of (normal) AICs \aics. 
\citet{iclp/Cruz-Filipe16} associated with such a set a semantic operator
% \footnote{Technically, his definition slightly differs from ours in the sense that $\nup$ is replaced by \body in his definition. However, it is not hard to see that the definitions are equivalent. The current definition satisifies our purpose better.} 
\begin{align*}\Op: &2^{\atoms}\to  2^{\atoms}: \UU \mapsto  \\ &\UU \biguplus \{\head(r) \mid r\in\aics \land  \UU(\db)\models \body(r)\}.\end{align*}

Cruz-Filipe argued that a semantics for AICs based on grounded fixpoints of \Op coincides with the intuitions on a large set of natural examples and that it solves problems with several previously existing semantics. 
In the following subsection, we define an approximator for \Op and hence, obtain a set of AFT-based semantics for AICs. 


% Now, with these definitions, we can rephrase the definition of the operator \Op.
% \begin{lemma}
%  Let \UU be an update set (viewed as a subset of \atoms) and $a$ an atom. 
%  Then $a\in \Op(\UU)$ if and only if 
%  \begin{itemize}
%   \item either $a\in \UU$ and $\suppout_\UU(a) =\lfalse$ or 
%   \item $a\not \in \UU$ and $\suppin_\UU(a)=\ltrue$. 
%  \end{itemize}
%  \end{lemma}

%  \begin{figure}
% 	\centering
% 	\begin{tabular}{|cc|c|c|c|}
% \cline{1-4}
% \multicolumn{2}{|c|}{\multirow{2}{*}{{ $a\in \Op(\UU)$, given $a\in \UU$} }}&\multicolumn{2}{c|}{$\suppin_{\db,\aics,\UU}(a)$}\\
% % \cline{3-4}
% 
% \multicolumn{2}{|c|}{}& \multicolumn{1}{c|}{$\ltrue$}  & \multicolumn{1}{c|}{$\lfalse$} \\
% \hline
% \multirow{2}{*}{$\suppin_{\db,\aics,\UU}(a)$}&\ltrue &	\ltrue & \lfalse 	\\
% \cline{2-4}
% &\lfalse	& \lfalse & \lfalse	\\
% % \cline{2-4}
% % &\lunkn 	& \lunkn& \lfalse & \lunkn 		\\
% \cline{1-4}
% 	\end{tabular}
% \label{fig:KT}
% \end{figure}

\subsection{An Approximator for \Op}

A \emph{partial action set} is a mapping $\UUU:\atoms \to \{\ltrue,\lfalse,\lunkn\}$.
The intended reading of such a mapping is that $\UUU(a)$ is true if $a$ is changed by $\UUU$, it is false if $a$ is not changed by $\UUU$ and it is unknown if $\UUU$ leaves it open whether or not $a$ is changed. 
Alternatively, a partial action set is identified with an element of $(2^\atoms)^C$ (as standard). 
The set of all partial action sets is denoted $P$.

A three-valued database is a mapping $\tdb: \atoms \to \{\ltrue,\lfalse,\lunkn\}$.
The intended reading is that $\tdb(a)$ is true if $a$ is in the database, $\tdb(a)$ is false if $a$ is not in the database and $\tdb(a)$ is unknown if $a$ is not in the database. 

If $\UUU$ is a partial action set and \db is a (regular) database, then we define $\UUU(\db)$ to be the three-valued database such that 
\[ \UUU(\db): a \mapsto \left \{\begin{array}{ll}
                                 \db(a) & \text{if }\UUU(a) = \lfalse\\
                                 \db(a)^{-1} & \text{if }\UUU(a) = \ltrue\\
                                 \lunkn & \text{otherwise.}
                                \end{array}\right.
                                \]



\begin{definition}\label{def:support}
Given a three-valued database \tdb, a set of AICs \aics and an update action $u$,  we define the \emph{support} of $u$ with respect to $\langle \tdb, \aics\rangle$ as 
\begin{align*}
 \supp_{\tdb,\aics}(u) &= \max_{\leq_t}\{\nup(r)^{\tdb}\mid r\in \aics \land \head(r) = u\},
\end{align*}
where $\nup^{\tdb}$ refers to the standard three-valued truth evaluation based on Kleene's truth tables \cite{Kleene38}.
\end{definition}

Using this notion of support, we define two additional values. 

\begin{definition}
If $a\in \atoms$, $\UUU$ is a partial set of update actions and $\langle \db, \aics\rangle$ as before, we define 
\begin{align*}
 \suppin_{\db,\aics,\UUU}(a) &= \supp_{\UUU(\db), \aics}(\change a)\\
  \suppout_{\db,\aics,\UUU}(a) &= \supp_{\UUU(\db), \aics}((\change a)^D)
\end{align*}
\end{definition}
As before, we often drop $\db$ and \aics from the notation if they are clear from the context. 
The first, \suppin, is true if there is support for $a$ being in the intended update set. It is true if there is at least one rule $r$ with $\change a$ as head such that $\nup(r)$ holds after updating \db with \UUU. The second value gives the support for removing $a$ from the update set, i.e., for keeping $a$ as it is in the database (hence the name choice). 






\begin{definition}
% \bart{truth tables are not so nice. Actually, a case split should be easier}
Given \db and \aics. We define an operator $\Ap: P\to P$, as follows:

% given by the following truth tables:
% 
% % \begin{figure}
% 	\centering
% % % \begin{minipage}{0.3\linewidth}
% 	\begin{tabular}{|cc|c|}
% \cline{1-3}
% \multicolumn{2}{|c|}{}&\multicolumn{1}{c|}{ $\Ap(\UUU)(a)$ if $\UUU(a)=\ltrue$}\\
% % \cline{3-5}
% \hline
% 
% \multirow{3}{*}{$\suppout_\UUU(a)$}&\ltrue &	\lfalse	\\
% \cline{2-3}
% &\lunkn 	& \lunkn		\\
% \cline{2-3}
% &\lfalse	& \ltrue		\\
% \cline{1-3}
% 	\end{tabular}\\
% % \end{minipage}
% 
% \quad\\ 
% 	\begin{tabular}{|cc|c|}
% \cline{1-3}
% \multicolumn{2}{|c|}{}&\multicolumn{1}{c|}{ $\Ap(\UUU)(a)$ if $\UUU(a)=\lfalse$}\\
% % \cline{3-5}
% \hline
% 
% \multirow{3}{*}{$\suppin_\UUU(a)$}&\ltrue &	\ltrue	\\
% \cline{2-3}
% &\lunkn 	& \lunkn		\\
% \cline{2-3}
% &\lfalse	& \lfalse		\\
% \cline{1-3}	\end{tabular}
% 
% 	\quad\\ 
% 
% 	
% % \begin{minipage}{0.3\linewidth}
% 	\begin{tabular}{|cc|c|c|c|}
% \cline{1-5}
% \multicolumn{2}{|c|}{\multirow{2}{*}{{ $\Ap(\UUU)(a)$ if $\UUU(a)=\lunkn$} }}&\multicolumn{3}{c|}{$\suppout_\UUU(a)$}\\
% % \cline{3-5}
% 
% \multicolumn{2}{|c|}{}& \ltrue & \lunkn & \lfalse \\
% \hline
% \multirow{3}{*}{$\suppin_\UUU(a)$}&\ltrue &	\lunkn & \lunkn & \ltrue	\\
% \cline{2-5}
% &\lunkn	& \lunkn & \lunkn & \lunkn		\\
% \cline{2-5}
% &\lfalse 	& \lfalse& \lunkn & \lunkn 		\\
% \cline{1-5}
% 	\end{tabular}
\begin{compactitem}
 \item If $\UUU(a)=\lfalse$, then $\Ap(\UUU)(a) = \suppin_\UUU(a).$
 \item If $\UUU(a)=\ltrue$, then $\Ap(\UUU)(a) = \suppout_\UUU(a)^{-1}.$
 \item Otherwise (i.e., if $\UUU(a) = \lunkn$):
  \begin{compactitem}
    \item if $\suppin_\UUU(a) = \ltrue$ and $\suppout_\UUU(a)=\lfalse$, then $\Ap(\UUU)(a)=\ltrue$;
    \item if $\suppout_\UUU(a) = \ltrue$ and $\suppin_\UUU(a)=\lfalse$, then $\Ap(\UUU)(a)=\lfalse$;
    \item otherwise, $\Ap(\UUU)(a)=\lunkn$.
\end{compactitem}

\end{compactitem}

 
\end{definition}

The above definitions is motivated as follows. Assume $\UUU$ is a three-valued update containing some three-valued information on the intended update. In this case $\Ap(\UUU)$ represents a revised update, using the AICs in \aics. 
In the case where $\UUU(a)=\lfalse$, $a$ is not an element of the (three-valued) update at hand. The only way to add $a$ to the update is if some rule supports adding $a$ (changing $a$). This is exactly captured by $\suppin$. 
The case for $\UUU(a)=\ltrue$ is completely symmetrical, in this case the only reason for removing $a$ from the update at hand is if there is some rule that supports ``keeping $a$'', i.e., that supports $\change a^D$. 
In the last case, where $\UUU(a)=\lunkn$, we have no information what the update does to $a$ yet. In this case, we can derive that $a$ \emph{must} be in the update if we already have support for $\change a$ and we are sure that there is no support for keeping $a$ (for $\change a^D$). Similarly, we can derive that $a$ \emph{must not} be in the update if we have support for $\change a^D$ but not for $\change a$. 
In all other cases, we derive nothing about $a$ being in the update or not. 


% We intend \Ap to be an approximator of \Op. One of the requirements of an approximator is that it agrees with \Op whenever \UUU is two-valued. This explains the exact values (\ltrue and \lfalse) in the the first two tables. 
% A second requirement is that an approximator is \leqp-monotone. 
% This explains the $\lunkn$ values in the first two tables. Indeed, for instance for the first table, if $\UUU(a)=\ltrue$ and $\suppout_\UUU(a)=\lunkn$, this means that there is at least one rule with $r$ with $\nup(r)^\UUU=\lunkn$. Without a priori knowledge of the structures of the rules, in such a situation it is still possible to obtain $\UUU'\geqp\UUU$ and $\UUU''\geqp \UUU$ such that $\nup(r)^{\UUU'}=\lfalse$ and $\nup(r)^{\UUU''}=\ltrue$. As such, in order to have \leqp-monotonicity, we must have that $\Ap(\UUU)\leqp\ltrue$ and $\Ap(\UUU)\leqp \lfalse$, hence $\Ap(\UUU)=\lunkn$.
% 
% Similar arguments also explain all the $\lunkn$ values found in the third table. 
% To explain the exact values in the last table, we consider two cases. 
% In both cases $\UUU(a)=\lunkn$, i.e., we have no prior knowledge of whether to update $a$ in the database or not. In the first case $\suppin_\UUU(a)=\ltrue$ and $\suppout_\UUU(a)=\lfalse$. This means that $\UUU$ contains enough information to decide that there is a rule that will require $\change a$ \emph{and} that there will no rule that requires $(\change a)^D$ in any more precise update set. 
% In such a situation, we have sufficient information to conclude that $\change a$ must be in the intended update set. 
% The other case is similar. 

\begin{proposition}
 \Ap is an approximator of \Op.
\end{proposition}
\begin{proof}
First, we show that $\Ap$ is $\leqp$-monotone. To see this, first note that Kleene-valuation is $\leqp$-monotone. Hence, for each $a\in \atoms$, also the functions that map $\UUU$ to $\suppin_\UUU(a)$ and $\suppout_\UUU(a)$ are $\leqp$-monotone. Now take some $a\in\atoms$ and suppose $\UUU'\geqp\UUU$. As argued before, in this case also $\suppin_{\UUU'}(a)\geqp \suppin_\UUU(a)$ and $\suppout_{\UUU'}(a)\geqp \suppout_\UUU(a)$. We show that $\Ap(\UUU')(a)\geqp \Ap(\UUU)(a)$ by a case analysis on the definition of $\Ap(\UUU)(a)$. 
\begin{compactitem}
\item If $\UUU(a)=\lfalse$, then $\UUU'(a)=\lfalse$ as well by $\leqp$-monotonicity. In this case $\Ap(\UUU')(a) = \suppin_{\UUU'}(a) \geqp \suppin_{\UUU}(a) =  \Ap(\UUU)(a)$. 
\item The case where $\UUU(a)=\ltrue$ is similar.
\item Assume $\UUU(a) = \lunkn$. 
\begin{compactitem}
\item If $\suppin_\UUU(a) = \ltrue$ and $\suppout_\UUU(a)=\lfalse$, then $\Ap(\UUU)(a)=\ltrue$ and also $\suppin_{\UUU'}(a) = \ltrue$ and $\suppout_{\UUU'}(a)=\lfalse$. Hence if $\UUU'(a)=\lunkn$, this is trivially proven. In case $\UUU'(a)=\ltrue$, $\Ap(\UUU')(a) = \suppout_{\UUU'}(a)^{-1}=\ltrue$ and in case $\UUU'(a)=\lfalse$, $\Ap(\UUU')(a)= \suppin_{\UUU'}(a)= \ltrue$. Hence, in all cases $\Ap(\UUU)(a) = \Ap(\UUU')(a)$ and the claim follows.
\item The case where $\suppout_\UUU(a)=\ltrue$ and $\suppin_\UUU(a) = \lfalse$ is similar to the previous.
\item In all other cases, $\Ap(\UUU)(a)=\lunkn$, hence $\Ap(\UUU')(a)\geqp \Ap(\UUU)(a)$ is trivially satisfied.
\end{compactitem}

\end{compactitem}

Secondly, we show that on two-valued update sets, $\Op$ and $\Ap$ coincide, i.e., that for all $\UU$, $\Op(\UU) =  \Ap(\UU)$. Take any $a \in \atoms$, we again prove this claim by a case analysis on the definition of of $\Ap(\UU)(a)$. 
\begin{compactitem}
 \item If $\UU(a)=\lfalse$, then $\Op(\UUU)(a)= \ltrue$ if and only if there is some rule $r\in \eta$ with $\UU(\db) \models \body(r)$ and $\head(r)=\change a$. I.e., $\Op(\UU)(a)$ is true if and only if $\suppin_{\UU}(a) = \ltrue$, if and only if $\Ap(\UU)(a)=\ltrue$. 
 \item The case for $\UU(a)=\lfalse$ is similar. 
 \item The case where $\UU(a)= \lunkn$ cannot occur, since $\UU$ is two-valued. \qedhere
\end{compactitem}

\end{proof}

Since \Ap is an approximator, it defines a family of semantics for AICs. 

\begin{definition}\label{def:semantics}
 Let $\fulldb$ be a database. 
 \begin{compactitem}
  \item A \emph{partial stable repair} of \fulldb is a three-valued update set \UUU such that \UUU is a partial $\Ap$-stable fixpoint. A \emph{stable repair} is a partial stable repair that is two-valued. 
  \item The \emph{AFT-well-founded repair} of \fulldb is the $\Ap$-well-founded fixpoint (in general, this is a three-valued update set). 
  \item The \emph{Kripke-Kleene repair} of \fulldb is the $\Ap$-Kripke-Kleene fixpoint (in general, this is a three-valued update set). 
%   \item A \emph{supported 
  \item A \emph{partial grounded repair} of \fulldb is a three-valued update set \UUU such that \UUU is a partial $\Ap$-grounded fixpoint. A \emph{grounded repair} is a partial grounded repair that is two-valued. 
 \end{compactitem}

\end{definition}
\todo{state somewhere: it follwos easily that each of these repairs, if they are two-valued, they are indeed ``minimal weak repairs'' (i.e., repairs according to AIC terminology). }

\todo{somewhere say something abut hte name clash: well-founded vs aft-well-founded}

Grounded repairs were defined previously by \citet{}. All other classes of repairs defined in Definition \ref{def:semantics} are newly introduced semantics by the current paper. 
We now illustrate these semantics by means of some examples. 


\begin{example}
 Consider the following set \aics of AICs:
\begin{align*}
 \lnot a \aicrule \add a\\
 a \land \lnot b \aicrule \add b\\
 \lnot a \land \lnot b \land \lnot c \aicrule \add c\\
 a \land c \land b \aicrule \remove b
\end{align*} with $\db = \emptyset$.
Now, the \Ap-well-founded fixpoint can be computed as the limit of a well-founded induction. It starts at
\[\UUU_0: a\mapsto \lunkn, b\mapsto \lunkn, c\mapsto\lunkn.\]
Here, we see that 
\begin{align*}
 \suppin_{\UUU_0}(a) &= \ltrue, & \suppout_{\UUU_0}(a) &=\lfalse \\
 \suppin_{\UUU_0}(b) &= \lunkn, & \suppout_{\UUU_0}(b) &=\lunkn \\
 \suppin_{\UUU_0}(c) &= \lunkn, & \suppout_{\UUU_0}(c) &=\lfalse 
\end{align*}
Hence, 
\[\UUU_1 = \Ap(\UUU_0): a\mapsto \ltrue, b\mapsto \lunkn, c\mapsto\lunkn\]
is a refinement of $\UUU_0$. 
Now, it can be verified that $\UUU_1$ is a fixpoint of $\Ap$. This is the Kripke-Kleene fixpoint. It is a partial repair set and provides the information that $a$ must be repaired, but it uncertain about $b$ and $c$. 

A well-founded induction continues by unfoundedness refinement. 
It can be verified that 
\[\UUU_2 = a\mapsto \ltrue, b\mapsto \lunkn, c\mapsto\lfalse\]
is an unfoundedness refinement of $\UUU_1$.
This follows easily from the fact that 
\[\UUU_3 = \Ap(\UUU_2)= a\mapsto \ltrue, b\mapsto \ltrue, c\mapsto\lfalse.\]
Hence $\UUU_3$ is an application refinement of $\UUU_2$. Since this is an exact point, it is the \Ap-well-founded fixpoint of \Op. It is clearly the intended repair in this example.

Note that in this example, unfoundedness refinements take care of minimisations of repairs.  
\end{example}

\begin{example}
 Consider the following set \aics of AICs:
\begin{align*}
 a \land \lnot b&\aicrule \add b\\
 \lnot a \land b &\aicrule \add a \\
 \lnot a \land \lnot b \land \lnot c &\aicrule \add c
 \end{align*} with $\db = \emptyset$.

Now, the \Ap-well-founded fixpoint can be computed as the limit of a well-founded induction. It starts at
\[\UUU_0: a\mapsto \lunkn, b\mapsto \lunkn, c\mapsto\lunkn.\]
Here, we see that 
\begin{align*}
 \suppin_{\UUU_0}(a) &= \lunkn, & \suppout_{\UUU_0}(a) &=\lfalse \\
 \suppin_{\UUU_0}(b) &= \lunkn, & \suppout_{\UUU_0}(b) &=\lfalse \\
 \suppin_{\UUU_0}(c) &= \lunkn, & \suppout_{\UUU_0}(c) &=\lfalse 
\end{align*}
Hence, $\Ap(\UUU_0)=\UUU_0$ and $\UUU_0$ is the \Ap-Kripke-Kleene fixpoint. 
A well-founded induction can continue with unfoundedness refinements. Indeed, consider 
\[\UUU_1: a\mapsto \lfalse, b\mapsto \lfalse, c\mapsto\lunkn.\]
Since 
\[\Ap(\UUU_1) = a\mapsto \lfalse, b\mapsto \lfalse, c\mapsto \ltrue,\] it holds that $\UUU_1$ is an unfoundedness refinement of $\UUU_2$. 
Finally, we can conclude that $\UUU_2:=\Ap(\UUU_1)$ is the \Ap-well-founded fixpoint. This corresponds to the intended repair. 
\end{example}

As can be expected, not every set of AICs has a two-valued well-founded repair. That would simply be too much to ask. It would mean that for every set of AICs we can unambiguously define a single repair. The following example illustrates that this is indeed not always the case. It also illustrates that (for this specific example), \Ap-stable repairs provide a solution that corresponds to the intuitions. 

\begin{example}
 Consider the following set \aics of AICs:
\begin{align*}
 \lnot a \land \lnot b&\aicrule \add a\\
 \lnot a \land \lnot b&\aicrule \add b\\
 a \land \lnot c &\aicrule \add c 
 \end{align*} with $\db = \emptyset$.
 
 Intuitively, \aics has two ``good'' repairs. The first two rules state that either $a$ or $b$ should be added in order to ``fix'' the violated constraint $\lnot (\lnot a \land \lnot b)$. 
 Depending on that choice, also $c$ might have to be added to the repair. The two intended repairs are thus $\{\add a,\add c\}$ and $\{\add b\}$. 
 Let us investigate what the different AFT-style semantics give in this case. 
 
 Consider 
\[\UUU_0: a\mapsto \lunkn, b\mapsto \lunkn, c\mapsto\lunkn.\]

Here, it holds that 
\begin{align*}
 \suppin_{\UUU_0}(a) &= \lunkn, & \suppout_{\UUU_0}(a) &=\lfalse \\
 \suppin_{\UUU_0}(b) &= \lunkn, & \suppout_{\UUU_0}(b) &=\lfalse \\
 \suppin_{\UUU_0}(c) &= \lunkn, & \suppout_{\UUU_0}(c) &=\lfalse 
\end{align*}
Hence, $\Ap(\UUU_0) = \UUU_0$ and $\UUU_0$ is the \Ap-Kripke-Kleene fixpoint. 
Furthermore, we claim that there are no unfoundedness refinements of $\UUU_0$ and hence that $\UUU_0$ is also the \Ap-well-founded fixpoint. To see that our claim indeed holds, notice that any unfoundedness refinement of $\UUU_0$ should consist of making a subset of $U$ of $\{a,b,c\}$ false, in such a way that for each $u\in U$, $\Ap(\UUU_0[U: \lfalse])(u)=\lfalse$. 
Assume $a\in U$. In order for $\Ap(\UUU_0[U: \lfalse])(a)$ to be false $b$ must be $\ltrue$ in $\UUU_0[U: \lfalse]$ (otherwise the body of the rule defining $\add a$ is unknown or true). That is not possible, hence $a\not \in U$. From a similar argument, we find that $b\not \in U$ and $c\not \in U$. 
Trivially, the two intended repairs are more precise than the well-founded fixpoint. 

Now, let us check whether $\UU := \{\add a, \add c\}$ is a stable fixpoint. 
For this, we need to verify if 
\[\UU =\lfp(\Ap(\cdot,\UU)_1).\]
Define $\UU_0=\emptyset$. Then 
\[(\UU_0,\UU) = a \mapsto \lunkn, b\mapsto \lfalse, c\mapsto \lunkn.\]
Hence 
\[\Ap(\UU_0,\UU) = a \mapsto \ltrue, b\mapsto \lunkn, c \mapsto \lunkn\]
and 
\[\UU_1 := \Ap(\UU_0,\UU)_1 = \{a\}.\]
Similarly, 
\[(\UU_1,\UU) = a \mapsto \ltrue, b\mapsto \lfalse, c\mapsto \lunkn.\]
Hence 
\[\Ap(\UU_1,\UU) = a \mapsto \ltrue, b\mapsto \false, c \mapsto \lunkn\]
and 
\[\UU_2 := \Ap(\UU_1,\UU)_1 = \UU.\]
Furthermore, $\Ap(\UU_2,\UU) = \UU_2=\UU$, hence  we find that indeed, \UU is an \Ap-stable fixpoint. 
The case for $\{\add b\}$ is similar. 

It can also be verified that there are no other $\Ap$-stable fixpoints. Due to minimality, no other could contain $b$, hence they must be subsets of $\{a,c\}$. Again, due to minimality, the only such subset is \UU. 

\end{example}
Hence, in the above example, \Ap-stable repairs capture the intended semantics. 


\todo{start new section here?}

We now show that all of these semantics are nicely invariant under shifting. 
\begin{proposition}
 \Ap, and hence also \Op, is invariant under shifting.
\end{proposition}
\begin{proof}
 \todo{will follow easily from the fact that we define everything in terms of $\change a$ and not in terms of $a$ directly. }
\end{proof}

\begin{proposition}\label{prop:wf-wf}
 Suppose the AFT-well-founded repair is two-valued. In this case it is also well-founded (as define by \citet{}). 
\end{proposition}
\begin{proof}
Let $\left(\UUU_i\right)_{i\leq k}$ be a well-founded induction of \Ap. 
For each $i$, define $\UU_i$ as $\{a \in \atoms \mid \UUU_i=\ltrue\}$. 
We will prove the following claim by induction on the length $k$ of the well-founded induction (note that we restrict to finite well-founded inductions here since we assumed $\atoms$ is a finite set in the first place). 

There exists a sequence $\alpha_1,\dots,\alpha_n$ such that $\UU_k=\{\alpha_1,\dots,\alpha_n\}$ and, for each $i\in\{1,\dots,n\}$, there is a rule $r_i$ such that $\{\alpha_1,\dots,\alpha_{i-1}\}(\db) \models \body (r_i)$ and $\alpha_i = \head(r_i)$.

From this claim, taking any terminal well-founded induction yields the desired result. 

We now show the claim indeed holds. 
The claim is trivial for $k=0$. Assume the claim holds for $k$, we show that it also holds for $k+1$. 
Thus assume $\alpha_1,\dots,\alpha_n$ is a sequence with $\UU_{k} = \{ \alpha_1,\dots,\alpha_n\}$ satisfying the above condition. 
If $\UUU_{k+1}$ is an unfoundedness refinement of $\UUU_k$, then $\UU_{k+1}=\UU_k$ and there is nothing to show. Hence, assume that $\UUU_k \leqp \UUU_{k+1}\leqp \Ap(\UUU_k)$. In this case, $\UU_\{k+1\} = \UU_k \cup \{ b_j\mid 1\leq j\leq m\}$ for some sequence of elements $b_j$ such that $\Ap(\UUU_k)(b_j) = \ltrue$. For each $j$, let $\UU'_j$ denote $\{\alpha_1,\dots,\alpha_n,\beta_1,\dots,\beta_j\}$. 
We claim that the sequence 
$\alpha_1,\dots,\alpha_n,\beta_1,\dots,\beta_m$ still satisfies the condition in the claim. 
To see this, note that from the definition of $\Ap$, it follows that for each $j\in \{1,\dots, m\}$ there is a rule $r_j$ with $\nup(r)^{\UUU_k(\db)}=\ltrue$ and $\head(r_j)=b_j$. Furthermore, for each $j$ it holds that $\UU_{j-1}' \geqp \UUU_k$ hence also $\nup(r)^{\UU_{j-1}'}$. Since $b_j\not \in \UU_{j-1}$, we also see that $\body(r_j)^{\UU_{j-1}'} = \ltrue$. Hence, the claim indeed follows for $\beta+1$ as well. 

% 
% 
% $\alpha_1,\dots,\alpha_n$ such that $\UU=\{\alpha_1,\dots,\alpha_n\}$ and, for each $i\in\{1,\dots,n\}$, there is a rule $r_i$ such that $U_{i-1}(\db) \models \body (r_i)$ and $\alpha_i \in \head(r_i)$, where $U_{i-1} = \{\alpha_1,\dots,\alpha_{i-1}\}$.
% 
% 
%  \todo{idea of the proof. 
%  
%  Take a well-founded induction $\left(\UUU_i\right)_{i\leq \beta}$. For each $i$, define $\UU_i$ as equal to $\UUU_i$ except that everything unknown in $\UUU_i$ is interpreted as $\lfalse$ in $\UU_i$. It is clear that $\UUU_i\leqp\UU_i$ in this case. 
%  Now, the claim is that $\UU_i$ and $\UU_{i+1}$ differ only in a set of atoms that have at least one rule body satisfied in $\UU_i$. Furthermore, that body remains satisfied if we add them one by one. To see this, for any set $\UU$ such that $\UU_i\subseteq \UU \subseteq \UU_{i+1}$, it also holds that $\UU\geqp \UUU_i$. For each atom derived in $\UUU_{i+1}$, there is a rule $r$ with $\nup(r)^{\UUU_i}=\ltrue$ and $\head(r)=a$. Since truth evaluation is $\leqp$-monotone, it also holds that $\nup(r)^{\UU} = \ltrue$. Hence, we can add those atoms one by one (TODO: make this more formal: explicitly construct the sequence). }
 
\end{proof}
\begin{example}The converse of Proposition \ref{prop:wf-wf} does
not hold. Consider for instance the following set $\aics$ of AICs
   \begin{align*}
  a &\aicrule \remove a\\
  a\land b &\aicrule \remove b\\
  b \land c &\aicrule \remove  c
 \end{align*}
 and $\db=\{a,b,c\}$.
 In this case, the AFT-well-founded repair is $\UU_{AFT}: a \mapsto \ltrue, b\mapsto \lfalse, c\mapsto \ltrue$. This is clearly the intended repair. Indeed, the first rule dictates that $a$ needs to be removed no matter what. The second rule then becomes void (there is never a reason to remove $b$) and the last rule then dictates that also $c$ must be removed. 
 However, $a \mapsto \ltrue, b\mapsto \ltrue, c\mapsto \lfalse$ is also well-founded repair (according to \citet{}). 
\end{example}

\todo{check the link between ``justified repair'' and ``stable repair''. My feeling is that they should be very closely related. For instance in Example 20 in the GF and AIC paper, this is a case where stable coincides with justified. However, there is also a notion of ultimate stable repair (which coincides here with grounded). This is similar to logic programming, where 
\begin{align*}
 a &\lrule b.\\
 a &\lrule \lnot b.\\
b &\lrule a.
\end{align*}
does not have $\{a,b\}$ as a stable model, but does have it as an ultimate stable model. 


More explanation why I feel these two are related. The definition of justified repair works as follows. First, fix all no-effect actions. Those are the things you \emph{do not change}. Then, the condition is that we have a minimal model that has at least those actions. 
This is very similar to the notions of a reduct in logic programming: first fix the negative atoms (to get a reduct), then consider minimal models of the reduct. 
}

\begin{proposition}\label{prop:stable_is_justified}
If \UU is a \Ap-stable repair, then \UU is a justified repair. 
\end{proposition}
\todo{Throughout the paper, I sometimes use the symbol $a$ for an action, sometimes for an atom. That must be confusing. However, due to the identification of a set of update actions with a subset of \atoms this mixup I'm doing is not so strainge. It might be better to streamline it a bit more} 
\begin{proof}
We can safely assume that \UU is a repair of \db (otherwise, it is neither a justified repair, nor a $\Ap$-stable repair.


 Before starting the actual proof, we introduce a couple of auxiliary operators. 
 For each set of update actions $\VV$, let $\ext(\VV)$ denote $\VV\cup \neff_\UU(\db)$.
 Notice that even if $\VV$ is consistent, $\ext(\VV)$ can be inconsistent. 
 For each set of update actions $\VV$, let $\closure(\VV)$ denote \[\closure(\VV)= \VV\cup \{head(r) \mid \actof(\nup(r)) \subseteq \VV\}.\] 
%  \todo{maybe closure should be defined differently: probably we need to drop teh \VV}
 Now, we define the operator (on sets of update actions):
\[O: \VV \mapsto \closure(\ext(\VV)) \setminus \neff_\UU(\db).\]
Below, we will prove the following claims:
\begin{compactdesc}
 \item \textbf{Claim 1}: \UU is a minimal prefixpoint of $O$ if and only if $\UU$ is a justified repair of \fulldb. 
 \item \textbf{Claim 2}: For any literal $l$, $\actof(l)\in \VV\cup \neff_\UU(\db)$ if and only if $(\bar \VV, \bar \UU)(\db)(l) = \ltrue$. 
 \item \textbf{Claim 3}: For any literal $l$, $\actof(l)\in \closure(\ext(\VV))$ if and only if  $\supp_{(\bar\VV,\bar\UU)(\db),\aics}(l) = \ltrue$. 
 \item \textbf{Claim 4}: For every set of update actions $\VV\subseteq \UU$: 
 \[\Ap(\bar\VV,\bar\UU)_1\subseteq \overline{O(\VV)}.\] 
\end{compactdesc}
Now, assume $\UU$ is a $\Ap$-stable repair. Since we are only working with normal AICs $O$ is a monotone operator, hence it has a unique minimal prefixpoint, which is also its least fixpoint. Since $\UU$ is a repair, it is a fixpoint of $O$, we should show that it is minimal. Assume $\UU'\subseteq \UU$ is a prefixpoint of $O$ as well. This means $O(\UU')\subseteq \UU'$ 
and hence 
\[\Ap(\overline{\UU'},\bar\UU)_1 \subseteq \overline{(O(\UU'))}\subseteq \overline{\UU'},\]
i.e., $\overline{\UU'}$ is a prefixpoint of $\Ap(\cdot,\bar\UU)_1$. 
Since $\bar\UU$ is an $\Ap$-stable repair, $\bar\UU$ is the least prefixpoint of $\Ap(\cdot,\bar\UU)_1$ and thus $\bar\UU = \overline{\UU'}$. Hence indeed, $\UU$ is a justified repair. 


% 
% From Claim 4, it follows that this least fixpoint must thus also be the least fixpoint of $\Ap(\cdot,\bar\UU)_1$ (note that dropping the assumptions of consistency or of ``all actions should change \db'' never yields smaller fixpoints, since dropping one of these assumptions never adds subsets of this least fixpoint). 
% Hence, $\UU$ is a minimal prefixpoint of $O$ if and only if $\bar \UU$ is a stable fixpoint of $\Ap$. By Claim 1, we then find that our proposition indeed holds. 
% % 
% All that remains is to prove our claims. 

\textbf{Claim 1} This follows immediately from the definition of justified repair. Prefixpoints of the \closure operator are sets of update actions closed under \aics. Hence $\UU$ is a minimal prefixpoint of $O$ iff $\ext(\UU)$ is a minimal set of update actions that contains $\neff_{\UU}(\db)$ and is closed under $\aics$. 





\textbf{Claim 2} First assume that $\actof(l)\in\VV\cup\neff_\UU(\db)$. 
Assume $l=a$ or $l=\lnot a$ for some atom $a\in \atoms$.  We consider two cases:
\begin{compactitem}
 \item If $\actof(l)\in \neff_\UU(\db)$, then $\db(l) = \ltrue$ and $\UU$ does not change the value of $l$, hence $a\not\in\bar\UU$. Thus $(\bar \VV,\bar \UU)(a)=\lfalse$ and in this case $(\bar \VV,\bar \UU)(\db)(l) = \db(l) = \ltrue$. 
 \item If $\actof(l)\not\in \neff_\UU(\db)$, then it must hold that $\actof(l) \in \VV\subseteq \UU$. Since $\actof(l)\in \UU$ and every action in \UU changes \db, it must hold that $\db(\lit)=\lfalse$. Now, since $\lit \in \VV$, $a\in \bar \VV$ and $(\bar \VV, \bar \UU) (a) = \ltrue$. Thus $(\bar\VV,\bar\UU)(\db)(l) = \db(l)^{-1} = \ltrue$ in this case. 
\end{compactitem}
For the other direction, assume that $(\bar\VV,\bar\UU)(\db)(l) = \ltrue$. Furthermore, assume that $\actof(l)\not\in \neff_\UU(\db)$, we show that $l\in \VV$. 
We fist show that $\db\not\models l$. Assume towards contradiction that $\db \models l$. 
It must then hold that $l^D \in \UU$ since $\actof(l)\not\in\neff_\UU(\db)$. This means that $a\in \bar \UU$. 
However, 
since $(\bar \VV, \bar \UU)(\db)(l) = \ltrue =\db(l)$, it must hold that $(\bar \VV,\bar \UU)(a) = \lfalse$, i.e., that $a\not \in \bar \UU$. This yields a contradiction, hence we can safely assume that $\db\not\models l$. 
Now in this case 
$(\bar \VV, \bar \UU)(\db)(l) = \ltrue \db(l)^{-1}$. Hence it must hold that $(\bar \VV,\bar \UU)(a) = \ltrue$, i.e., that $a\in \bar \VV$. Since $\db(\lit) = \lfalse$, this means that $\lit\in \VV$, which is exactly what we needed to prove. 


\textbf{Claim 3} 
Let $l$ be a literal. 
It holds that  $\supp_{(\bar\VV,\bar\UU)(\db),\aics}(\actof(l)) = \ltrue$ if and only if there is some rule $r$ with $\head(r)=\actof(l)$ and $\nup(r)^{ (\bar\VV,\$, \bar\UU)(\db)} = \ltrue$. This means that for each literal $l'\in \nup(r)$, $l'^{(\bar\VV,\$, \bar\UU)(\db)} = \ltrue$. From Claim 2 it then follows that this is equivalent with the condition that each literal $l'\in\nup(r)$ is an element of   $\VV\cup \neff_\UU(\db)$, i.e., with  the condition that $\actof(l) \in \closure(\ext(\VV))$. 


\textbf{Claim 4}
Take an atom $a$ and a set $\VV$ of update actions. It holds that $a\in \Ap(\bar\VV,\bar\UU)_1)$ if and only if one of the following holds:
\begin{compactitem}
 \item $(\bar \VV,\bar \UU)(a) = \lfalse$ and $\supp_{(\bar\VV,\bar\UU)(\db),\aics}(\change a)=\ltrue$
 \item $(\bar \VV,\bar \UU)(l) = \lunkn$, $ \supp_{(\bar\VV,\bar\UU)(\db),\aics}(\change a)=\ltrue$ and $\supp_{(\bar\VV,\bar\UU)(\db),\aics}(\change a^D) = \lfalse$.
\end{compactitem}
In both cases, $\supp_{(\bar\VV,\bar\UU)(\db),\aics}(\change a)=\ltrue$, hence by Claim 3, $\change a\in \closure(\ext(\VV))$. Now if $\VV\subseteq \UU$, then $a\in\Ap(\bar\VV,\bar\UU)_1$ entails $a\in \bar\UU$, hence also $\change a \in \UU$ and thus $\change a \in \closure(\ext(\VV)) \cap \UU = O(\UU)$, which we needed to prove. 




% \todo{todo} Since we assumed that $\UU$ is a weak repair,  it follows easily that $\closure(\UU)=\UU$, that $\closure(\ext(\UU)) = \ext(\UU)$ and that $O(\UU) = \UU$. 
% Now, for a literal $a$, it holds that 
% 
% Take any $\VV\subseteq \UU$; it follow that every action in \VV changes \db and that \VV is consistent. 
% 
% Let $a$ be an update action. It hold that $a\in \closure(\ext(\VV))$ if and only if there is a rule $r$ with $\head(r)= a$ and $\actof(\nup(r))\subseteq \VV\cup\neff_\UU(\db)$
% 
% 
% 
% We first show that $O(\VV)\subseteq A(\bar\VV,\bar\UU)_1$.
% Take any action $a\in O(\VV)$
% 
% TODO: get to $a\in O(\VV)$ IFF $\suppin_\VV(a) = \ltrue$. 
% THen: we can't have both $a \in O(\VV)$ and $a^D\in O(\VV)$ since $O(\VV)\subseteq O(\UU) = \UU$ is consistent.
% 
% First notice that it follows easily from
%  
% %  $\actof(\nup(r))\subseteq \UU$ implies $\head(r)\cap \UU\neq \emptyset$
%  
%  
% 
% 
% 
% 
%  First assume $\UU$ is a justified repair. 
%  For each set of update actions $\UU'$, let $c(\UU')$ denote $\UU'\cup \neff_\UU(\db)$. 
%  Since $\UU$ is a justified repair, $s(\UU)$ is a justified action set. 
%  This means that 
%  
%  \todo{IDEA:
%  Consider the operator 
%  \[O: \UU'\mapsto close(c(\UU')) \setminus neff_\UU(\db)\]
%  My feeling is that $O= \Ap(\cdot,\UU)_1$
%  AND: that the condition ``justified repair'' can be rewritten to ``minimal prefixpoitn'' of $O$. In that case, since $O$ is monotone, we get that ``minimal prefixpoint'' coincides with least fixpoint. QED
%  (we will be using the fact the \aics is normal in the proof)
%  Be careful, this operator is not defined when $\UU'$ is inconsistent with $\neff$, however, it should suffice to have it defined when the union is consistent.
%  
%  
%  To see this, notice that NEFF = the stuff you don't change. In our representation of three-valued update sets, this EXACTLY corresponds to the upper bound}
%  
\end{proof}

\begin{example}
 The converse of Proposition \ref{prop:stable_is_justified} does not hold. Consider the following set \aics of AICs. 
 \begin{align*}
  \lnot a \lrule \add a\\
  a\land \lnot b \lrule \add b\\
  a \land \lnot b \lrule \remove a
 \end{align*}
 with $\db=\empty$. 
 In this case $\{\add a,\add b\}$ is a justified repair of \fulldb, but not a stable repair. 
 To see that it is not a stable repair, it suffices to note that 
 \[\Ap(\emptyset,\{a,b\}) = (\emptyset,\{a,b\})\]
 and hence
 \[
  \lfp \Ap(\cdot,\{a,b\})_1 = \emptyset\neq \{a,b\}.
 \]
To see that it is a justified repair, note that $\{\add a,\add b\}$ is the least set closed under \aics. 

\end{example}





\todo{link with logic programming. 
IF $\db=\empty$ and the only update actions in heads are of the form $\add a$, i.e., never $\remove a$. Then I think we can easily prove equivalence with logic programming. (syntactic transformation that transforms an AIC in a logic program such that the approximator is preserved (and hence also the various families of semantics are preserved). }

