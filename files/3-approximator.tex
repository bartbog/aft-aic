In this section, we define an approximator for \Op and hence, obtain a set of AFT-based semantics for AICs, based on intuitions similar to those underlying groundedness and various semantics from non-monotonic reasoning. 


% Now, with these definitions, we can rephrase the definition of the operator \Op.
% \begin{lemma}
%  Let \UU be an update set (viewed as a subset of \atoms) and $a$ an atom. 
%  Then $a\in \Op(\UU)$ if and only if 
%  \begin{itemize}
%   \item either $a\in \UU$ and $\suppout_\UU(a) =\lfalse$ or 
%   \item $a\not \in \UU$ and $\suppin_\UU(a)=\ltrue$. 
%  \end{itemize}
%  \end{lemma}

%  \begin{figure}
% 	\centering
% 	\begin{tabular}{|cc|c|c|c|}
% \cline{1-4}
% \multicolumn{2}{|c|}{\multirow{2}{*}{{ $a\in \Op(\UU)$, given $a\in \UU$} }}&\multicolumn{2}{c|}{$\suppin_{\db,\aics,\UU}(a)$}\\
% % \cline{3-4}
% 
% \multicolumn{2}{|c|}{}& \multicolumn{1}{c|}{$\ltrue$}  & \multicolumn{1}{c|}{$\lfalse$} \\
% \hline
% \multirow{2}{*}{$\suppin_{\db,\aics,\UU}(a)$}&\ltrue &	\ltrue & \lfalse 	\\
% \cline{2-4}
% &\lfalse	& \lfalse & \lfalse	\\
% % \cline{2-4}
% % &\lunkn 	& \lunkn& \lfalse & \lunkn 		\\
% \cline{1-4}
% 	\end{tabular}
% \label{fig:KT}
% \end{figure}

% \paragraph{An Approximator for \Op}

A \emph{partial action set} is a mapping $\UUU:\atoms \to \{\ltrue,\lfalse,\lunkn\}$. A partial action set \UUU is \emph{two-valued} if $\UUU(\atoms)\subseteq\{\ltrue,\lfalse\}$; in this case, we identify $\UUU$ with the action set $\{\change a\mid \UUU(a)=\ltrue\}$. 
The intended reading of such a mapping is that $\UUU(a)$ is true if $a$ is changed by $\UUU$, it is false if $a$ is not changed by $\UUU$ and it is unknown if $\UUU$ leaves it open whether or not $a$ is changed. 
Alternatively, a partial action set is identified with an element of $(2^\atoms)^c$, i.e., with a tuple $(\UUU_t,\UUU_{tu})$ with $\UUU_t\subseteq\UUU_{tu}$, where $\UUU_t$ contains all elements that map to $\ltrue$ and $\UUU_{tu}$ all elements that map either to $\ltrue$ or to $\lunkn$ (as standard). 
The set of all partial action sets is denoted $P$.
The truth order $\leqt$ on three-valued truth values is defined by $\lfalse\leqt\lunkn\leqt\ltrue$. The inverse of a truth value is $\lfalse^{-1}=\ltrue, \ltrue^{-1}=\lfalse, \lunkn^{-1}=\lunkn$.

A partial database is a mapping $\tdb: \atoms \to \{\ltrue,\lfalse,\lunkn\}$.
The intended reading is that $\tdb(a)$ is true if $a$ is in the database, $\tdb(a)$ is false if $a$ is not in the database and $\tdb(a)$ is unknown otherwise. 

If $\UUU$ is a partial action set and \db is a (regular) database, then we define $\UUU(\db)$ to be the partial database such that 
\[ \UUU(\db): a \mapsto \left \{\begin{array}{ll}
                                 \db(a) & \text{if }\UUU(a) = \lfalse\\
                                 \db(a)^{-1} & \text{if }\UUU(a) = \ltrue\\
                                 \lunkn & \text{otherwise,}
                                \end{array}\right.
                                \]
where $\db(a) = \ltrue$ if $a\in \db$ and $\db(a)=\lfalse$ otherwise. 



\begin{definition}\label{def:support}
Given a partial database \tdb, a set of AICs \aics and an update action $\alpha$,  we define the \emph{support} of $\alpha$ with respect to $\langle \tdb, \aics\rangle$ as 
\begin{align*}
 \supp_{\tdb,\aics}(\alpha) &= \max_{\leq_t}\{\nup(r)^{\tdb}\mid r\in \aics \land \head(r) = \alpha\},
\end{align*}
where $\nup(r)^{\tdb}$ refers to the standard three-valued truth evaluation of the formula\footnote{Technically, $\nup(r)$ is a set of literals; we identify it with the conjunction of those literals.} $\nup(r)$ in the partial interpretation \tdb based on Kleene's truth tables \cite{Kleene38} (see Figure~\ref{fig:KT}).
\end{definition}
Intuitively, this means that the support of an action is the highest truth value of the (non-updateable part of the) body of a rule with the action in question in the head. 


% \luis{$\leq_t$ was not defined}

\begin{figure}
	\centering
\begin{minipage}{0.3\linewidth}
	\begin{tabular}{|cc"c|c|c|}
\cline{1-5}
\multicolumn{2}{|c"}{\multirow{2}{*}{{ $A\land B$} }}&\multicolumn{3}{c|}{B}\\
% \cline{3-5}

\multicolumn{2}{|c"}{}& \ltrue & \lfalse & \lunkn \\
\thickhline
\multirow{3}{*}{A}&\ltrue &	\ltrue & \lfalse & \lunkn	\\
\cline{2-5}
&\lfalse	& \lfalse & \lfalse & \lfalse		\\
\cline{2-5}
&\lunkn 	& \lunkn& \lfalse & \lunkn 		\\
\cline{1-5}
	\end{tabular}
\end{minipage}
\begin{minipage}{0.3\linewidth}
	\begin{tabular}{|cc"c|c|c|}
\cline{1-5}
\multicolumn{2}{|c"}{\multirow{2}{*}{{ $A\lor B$} }}&\multicolumn{3}{c|}{B}\\
% \cline{3-5}

\multicolumn{2}{|c"}{}& \ltrue & \lfalse & \lunkn \\
\thickhline
\multirow{3}{*}{A}&\ltrue &	\ltrue & \ltrue & \ltrue	\\
\cline{2-5}
&\lfalse	& \ltrue & \lfalse & \lunkn		\\
\cline{2-5}
&\lunkn 	& \ltrue& \lunkn & \lunkn 		\\
\cline{1-5}
	\end{tabular}
\end{minipage}
\begin{minipage}{0.2\linewidth}
	\begin{tabular}{|cc"c|}
\cline{1-3}
&&{{{ $ \lnot A$} }}\\
% \cline{3-5}

% \multicolumn{2}{|c"}{}& \ltrue & \lfalse & \lunkn \\
\thickhline
\multirow{3}{*}{A}&\ltrue &	\lfalse\\
\cline{2-3}
&\lfalse	& \ltrue	\\
\cline{2-3}
&\lunkn 	& \lunkn 		\\
\cline{1-3}
	\end{tabular}
\end{minipage}
\caption{The Kleene truth tables \cite{Kleene38}.}
\label{fig:KT}


\end{figure}


Using this notion, we define two additional values. 

\begin{definition}
If $a\in \atoms$, $\UUU$ is a partial set of update actions and $\langle \db, \aics\rangle$ as before, we define 
\begin{align*}
 \suppin_{\db,\aics,\UUU}(a) &= \supp_{\UUU(\db), \aics}(\change a)\\
  \suppout_{\db,\aics,\UUU}(a) &= \supp_{\UUU(\db), \aics}((\change a)^D)
\end{align*}
\end{definition}
As before, we often drop $\db$ and \aics from the notation if they are clear from the context. 
Intuitively, 
$\suppin_{\UUU}(a)$ is true if there is support for \emph{changing} $a$ after updating the database with $\UUU$, i.e., if at least one rule $r$ with $\head(r)=\change a$ has $\nup(r)^{\UUU(\db)} = \ltrue$;  
$\suppin_{\UUU}(a)$ is unknown if it is not true and there is at least one rule $r$ with $\head(r)=\change a$ that has $\nup(r)^{\UUU(\db)} = \lunkn$; 
otherwise, all rules $r$ with $\head(r)=\change a$ have a false (non-updateable part of their) body and thus, $\suppin_{\UUU}(a)$ is false. 
Similarly, $\suppout_{\UUU}(a)$ expresses the support for \emph{keeping} $a$ as it is in the database (hence the name choice). 

\begin{example}
 Consider $\db=\emptyset$ and the following set $\aics$:
 \begin{align*}
   \lnot a\land b &\aicrule \add a\\  a \land c\land d &\aicrule\remove a\,.
 \end{align*}
 Consider $\UUU = \{a\mapsto\ltrue,b\mapsto\ltrue, c\mapsto\ltrue, d\mapsto\lunkn\}$. 
 Then  $\suppin_{\db,\aics,\UUU}(a)=\ltrue$ and $\suppout_{\db,\aics,\UUU}(a)=\lunkn$. 
\end{example}

% \todo{REVIEWER 4: example please}




\begin{definition} \label{def:apfull}
% \overlinet{truth tables are not so nice. Actually, a case split should be easier}
Given \db and \aics, we define an operator $\Apfull: P\to P$, as follows:

% given by the following truth tables:
% 
% % \begin{figure}
% 	\centering
% % % \begin{minipage}{0.3\linewidth}
% 	\begin{tabular}{|cc|c|}
% \cline{1-3}
% \multicolumn{2}{|c|}{}&\multicolumn{1}{c|}{ $\Ap(\UUU)(a)$ if $\UUU(a)=\ltrue$}\\
% % \cline{3-5}
% \hline
% 
% \multirow{3}{*}{$\suppout_\UUU(a)$}&\ltrue &	\lfalse	\\
% \cline{2-3}
% &\lunkn 	& \lunkn		\\
% \cline{2-3}
% &\lfalse	& \ltrue		\\
% \cline{1-3}
% 	\end{tabular}\\
% % \end{minipage}
% 
% \quad\\ 
% 	\begin{tabular}{|cc|c|}
% \cline{1-3}
% \multicolumn{2}{|c|}{}&\multicolumn{1}{c|}{ $\Ap(\UUU)(a)$ if $\UUU(a)=\lfalse$}\\
% % \cline{3-5}
% \hline
% 
% \multirow{3}{*}{$\suppin_\UUU(a)$}&\ltrue &	\ltrue	\\
% \cline{2-3}
% &\lunkn 	& \lunkn		\\
% \cline{2-3}
% &\lfalse	& \lfalse		\\
% \cline{1-3}	\end{tabular}
% 
% 	\quad\\ 
% 
% 	
% % \begin{minipage}{0.3\linewidth}
% 	\begin{tabular}{|cc|c|c|c|}
% \cline{1-5}
% \multicolumn{2}{|c|}{\multirow{2}{*}{{ $\Ap(\UUU)(a)$ if $\UUU(a)=\lunkn$} }}&\multicolumn{3}{c|}{$\suppout_\UUU(a)$}\\
% % \cline{3-5}
% 
% \multicolumn{2}{|c|}{}& \ltrue & \lunkn & \lfalse \\
% \hline
% \multirow{3}{*}{$\suppin_\UUU(a)$}&\ltrue &	\lunkn & \lunkn & \ltrue	\\
% \cline{2-5}
% &\lunkn	& \lunkn & \lunkn & \lunkn		\\
% \cline{2-5}
% &\lfalse 	& \lfalse& \lunkn & \lunkn 		\\
% \cline{1-5}
% 	\end{tabular}
\begin{itemize}
 \item If $\UUU(a)=\lfalse$, then $\Apfull(\UUU)(a) = \suppin_\UUU(a).$
 \item If $\UUU(a)=\ltrue$, then $\Apfull(\UUU)(a) = \suppout_\UUU(a)^{-1}.$
 \item Otherwise (i.e., if $\UUU(a) = \lunkn$):
  \begin{itemize}
    \item if $\suppin_\UUU(a) = \ltrue$ and $\suppout_\UUU(a)=\lfalse$, then $\Apfull(\UUU)(a)=\ltrue$;
    \item if $\suppout_\UUU(a) = \ltrue$ and $\suppin_\UUU(a)=\lfalse$, then $\Apfull(\UUU)(a)=\lfalse$;
    \item otherwise, $\Apfull(\UUU)(a)=\lunkn$.
\end{itemize}

\end{itemize}
When $\db$ is clear from the context, we write \Ap for \Apfull.
 
\end{definition}

Definition \ref{def:apfull} is motivated as follows. Assume $\UUU$ is a partial update set containing some information on the intended update. In this case $\Ap(\UUU)$ represents a revised update, using the AICs in \aics. 
In the case where $\UUU(a)=\lfalse$, $a$ is not an element of the (partial) update set at hand. The only way to add $a$ to the update is if some rule supports changing $a$, which is captured by $\suppin$. 
The case for $\UUU(a)=\ltrue$ is completely symmetrical, in this case the only reason for removing $a$ from the update at hand is if there is some rule that supports keeping $a$.
In the last case, where $\UUU(a)=\lunkn$, we have no information what the update does to $a$ yet. In this case, we can derive that $a$ \emph{must} be in the update if we already have support for $\change a$ and we are sure that there is no support for keeping $a$ (for $\change a^D$). Similarly, we can derive that $a$ \emph{must not} be in the update if we have support for $\change a^D$ but not for $\change a$. 
In all other cases, we derive nothing about $a$ being in the update or not. 


% We intend \Ap to be an approximator of \Op. One of the requirements of an approximator is that it agrees with \Op whenever \UUU is two-valued. This explains the exact values (\ltrue and \lfalse) in the the first two tables. 
% A second requirement is that an approximator is \leqp-monotone. 
% This explains the $\lunkn$ values in the first two tables. Indeed, for instance for the first table, if $\UUU(a)=\ltrue$ and $\suppout_\UUU(a)=\lunkn$, this means that there is at least one rule with $r$ with $\nup(r)^\UUU=\lunkn$. Without a priori knowledge of the structures of the rules, in such a situation it is still possible to obtain $\UUU'\geqp\UUU$ and $\UUU''\geqp \UUU$ such that $\nup(r)^{\UUU'}=\lfalse$ and $\nup(r)^{\UUU''}=\ltrue$. As such, in order to have \leqp-monotonicity, we must have that $\Ap(\UUU)\leqp\ltrue$ and $\Ap(\UUU)\leqp \lfalse$, hence $\Ap(\UUU)=\lunkn$.
% 
% Similar arguments also explain all the $\lunkn$ values found in the third table. 
% To explain the exact values in the last table, we consider two cases. 
% In both cases $\UUU(a)=\lunkn$, i.e., we have no prior knowledge of whether to update $a$ in the database or not. In the first case $\suppin_\UUU(a)=\ltrue$ and $\suppout_\UUU(a)=\lfalse$. This means that $\UUU$ contains enough information to decide that there is a rule that will require $\change a$ \emph{and} that there will no rule that requires $(\change a)^D$ in any more precise update set. 
% In such a situation, we have sufficient information to conclude that $\change a$ must be in the intended update set. 
% The other case is similar. 

\begin{proposition}
 \Ap is an approximator of \Op.
\end{proposition}
% \begin{proof}[Sketch of the proof]
% \leqp-monotonicity of \Ap follows from the fact that Kleene-valuation is \leqp-monotone and 
% \end{proof}
\begin{proof}
First, we show that $\Ap$ is $\leqp$-monotone. To see this, first note that Kleene-valuation is $\leqp$-monotone. Hence, for each $a\in \atoms$, also the functions that map $\UUU$ to $\suppin_\UUU(a)$ and $\suppout_\UUU(a)$ are $\leqp$-monotone. Now take some $a\in\atoms$ and suppose $\UUU'\geqp\UUU$. Then  $\suppin_{\UUU'}(a)\geqp \suppin_\UUU(a)$ and $\suppout_{\UUU'}(a)\geqp \suppout_\UUU(a)$. We show that $\Ap(\UUU')(a)\geqp \Ap(\UUU)(a)$ by a case analysis on the definition of $\Ap(\UUU)(a)$. 
\begin{itemize}
\item If $\UUU(a)=\lfalse$, then $\UUU'(a)=\lfalse$ since $\UUU'\geqp\UUU$. In this case $\Ap(\UUU')(a) = \suppin_{\UUU'}(a) \geqp \suppin_{\UUU}(a) =  \Ap(\UUU)(a)$. 
\item The case where $\UUU(a)=\ltrue$ is similar.
\item Assume $\UUU(a) = \lunkn$. 
\begin{itemize}
\item If $\suppin_\UUU(a) = \ltrue$ and $\suppout_\UUU(a)=\lfalse$, then $\Ap(\UUU)(a)=\ltrue$ and also $\suppin_{\UUU'}(a) = \ltrue$ and $\suppout_{\UUU'}(a)=\lfalse$. Hence if $\UUU'(a)=\lunkn$, this is trivially proven. In case $\UUU'(a)=\ltrue$, $\Ap(\UUU')(a) = \suppout_{\UUU'}(a)^{-1}=\ltrue$ and in case $\UUU'(a)=\lfalse$, $\Ap(\UUU')(a)= \suppin_{\UUU'}(a)= \ltrue$. Hence, in all cases $\Ap(\UUU)(a) = \Ap(\UUU')(a)$ and the claim follows.
\item The case where $\suppout_\UUU(a)=\ltrue$ and $\suppin_\UUU(a) = \lfalse$ is similar to the previous.
\item In all other cases, $\Ap(\UUU)(a)=\lunkn$, hence $\Ap(\UUU')(a)\geqp \Ap(\UUU)(a)$ is trivially satisfied.
\end{itemize}

\end{itemize}

Secondly, we show that on two-valued update sets, $\Op$ and $\Ap$ coincide, i.e., that for all $\UU$, $\Op(\UU) =  \Ap(\UU)$. Take any $a \in \atoms$, we again prove this claim by a case analysis on the definition of of $\Ap(\UU)(a)$.
\begin{itemize}
 \item If $\UU(a)=\lfalse$, then $\Op(\UUU)(a)= \ltrue$ if and only if there is some rule $r\in \eta$ with $\UU(\db) \models \body(r)$ and $\head(r)=\change a$. I.e., $\Op(\UU)(a)$ is true if and only if $\suppin_{\UU}(a) = \ltrue$, if and only if $\Ap(\UU)(a)=\ltrue$. 
 \item The case for $\UU(a)=\lfalse$ is similar. 
 \item The case where $\UU(a)= \lunkn$ cannot occur, since $\UU$ is two-valued. \qedhere
\end{itemize}
\end{proof}

Since \Ap is an approximator, it defines a family of semantics for AICs. 

\begin{definition}\label{def:semantics}
 Let $\fulldb$ be a database. 
 \begin{itemize}
  \item A \emph{partial stable repair} of \fulldb is a partial update set \UUU such that \UUU is a partial $\Ap$-stable fixpoint. A \emph{stable repair} is a partial stable repair that is two-valued. 
  \item The \emph{AFT-well-founded repair} of \fulldb is the $\Ap$-well-founded fixpoint (in general, this is a partial update set). 
  \item The \emph{Kripke-Kleene repair} of \fulldb is the $\Ap$-Kripke-Kleene fixpoint (in general, this is a partial update set). 
%   \item A \emph{supported 
  \item A \emph{partial grounded repair} of \fulldb is a partial update set \UUU such that \UUU is a partial $\Ap$-grounded fixpoint \mycite{PartialGroundedFixpoints}. A \emph{grounded repair} is a partial grounded repair that is two-valued. 
 \end{itemize}
\end{definition}

The terminology in the above definition uses ``repairs'' for certain classes of fixpoints of a semantic operator. It follows easily that  all two-valued update sets that are called ``repair'' in the the above definition, indeed are repairs according to AIC terminology. 
This paper is the first work that studies partial (non-two-valued) repairs. 
% Indeed, this follows from the fact that 
 
% \todo{state somewhere: it follwos easily that each of these repairs, if they are two-valued, they are indeed ``minimal weak repairs'' (i.e., repairs according to AIC terminology). }

The well-founded semantics induced by AFT can in general differ from the existing well-founded semantics for AICs, as we show in Example \ref{ex:wf:wf}. To distinguish the two, we use the term \emph{AFT-well-founded semantics}. % for the well-founded semantics induced by AFT. 

It follows directly from Proposition 3.2 of \citet{ijcai/BogaertsVD15} and Proposition \ref{prop:grounded:ok} that grounded repairs as defined in Definition \ref{def:semantics} coincide with  Definition~\ref{def:grounded}. 
All other classes of repairs are new. 
% \luis{I think this is important. Should we include a proof? Or is this trivial?}
% All other classes of repairs
%defined in Definition \ref{def:semantics} 
% are newly introduced semantics by the current paper. 

We now illustrate these semantics by means of some examples. 

\todo{examples of (partial) grounded fixpoint}
\begin{example}
 Consider the following set \aics of AICs:
\begin{align*}
 \lnot a &\aicrule \add a \\ 
 \lnot a \land \lnot b \land \lnot c &\aicrule \add c\\
 a \land \lnot b &\aicrule \add b \\
 a \land c \land b &\aicrule \remove b
\end{align*} with $\db = \emptyset$.
Now, the \Ap-well-founded fixpoint can be computed as the limit of a well-founded induction. It starts at
\[\UUU_0: a\mapsto \lunkn, b\mapsto \lunkn, c\mapsto\lunkn.\]
Here, we see that 
\begin{align*}
 \suppin_{\UUU_0}(a) &= \ltrue, & \suppout_{\UUU_0}(a) &=\lfalse \\
 \suppin_{\UUU_0}(b) &= \lunkn, & \suppout_{\UUU_0}(b) &=\lunkn \\
 \suppin_{\UUU_0}(c) &= \lunkn, & \suppout_{\UUU_0}(c) &=\lfalse 
\end{align*}
Hence, 
\[\UUU_1 = \Ap(\UUU_0): a\mapsto \ltrue, b\mapsto \lunkn, c\mapsto\lunkn\]
is a refinement of $\UUU_0$. 
Now, it can be verified that $\UUU_1$ is a fixpoint of $\Ap$. This is the Kripke-Kleene fixpoint. It is a partial repair set and provides the information that $a$ must be repaired, but it uncertain about $b$ and $c$. 

A well-founded induction continues by unfoundedness refinement. 
It can be verified that 
\[\UUU_2 = a\mapsto \ltrue, b\mapsto \lunkn, c\mapsto\lfalse\]
is an unfoundedness refinement of $\UUU_1$.
This follows easily from the fact that 
\[\UUU_3 = \Ap(\UUU_2)= a\mapsto \ltrue, b\mapsto \ltrue, c\mapsto\lfalse.\]
Hence $\UUU_3$ is an application refinement of $\UUU_2$. Since this is an exact point, it is the \Ap-well-founded fixpoint of \Op. It is clearly the intended repair in this example.

Note that in this example, unfoundedness refinements take care of minimizations of repairs.  
\end{example}



\begin{example}
 Consider the following set \aics of AICs:
\begin{align*}
 a \land \lnot b&\aicrule \add b \\
 \lnot a \land b &\aicrule \add a \\
 \lnot a \land \lnot b \land \lnot c &\aicrule \add c
 \end{align*} with $\db = \emptyset$. Intuitively, we expect $\add c$ to be an element of ``good'' repairs, and (following the minimality of change principle), no other actions to be in ``good'' repairs. 

Now, the \Ap-well-founded fixpoint can be computed as the limit of a well-founded induction. It starts at
\[\UUU_0: a\mapsto \lunkn, b\mapsto \lunkn, c\mapsto\lunkn.\]
Here, we see that 
\begin{align*}
 \suppin_{\UUU_0}(a) &= \lunkn, & \suppout_{\UUU_0}(a) &=\lfalse \\
 \suppin_{\UUU_0}(b) &= \lunkn, & \suppout_{\UUU_0}(b) &=\lfalse \\
 \suppin_{\UUU_0}(c) &= \lunkn, & \suppout_{\UUU_0}(c) &=\lfalse 
\end{align*}
Hence, $\Ap(\UUU_0)=\UUU_0$ and $\UUU_0$ is the \Ap-Kripke-Kleene fixpoint. 
A well-founded induction can continue with unfoundedness refinements. Indeed, consider 
\[\UUU_1: a\mapsto \lfalse, b\mapsto \lfalse, c\mapsto\lunkn.\]
Since 
\[\Ap(\UUU_1) = a\mapsto \lfalse, b\mapsto \lfalse, c\mapsto \ltrue,\] it holds that $\UUU_1$ is an unfoundedness refinement of $\UUU_1$. 
Finally, we can conclude that $\UUU_2:=\Ap(\UUU_1)$ is the \Ap-well-founded fixpoint. This corresponds to the intended repair.
\end{example}

As can be expected, not every set of AICs has a two-valued well-founded repair. That would simply be too much to ask. It would mean that for every set of AICs we can unambiguously identify a single repair. The following example illustrates that this is indeed not always the case. It also illustrates that (for this specific example), \Ap-stable repairs provide a solution that corresponds to the intuitions. 

\begin{example}
 Consider the following set \aics of AICs:
\begin{align*}
 \lnot a \land \lnot b&\aicrule \add a \\
 \lnot a \land \lnot b&\aicrule \add b\\
 a \land \lnot c &\aicrule \add c 
 \end{align*} with $\db = \emptyset$.
%  
 Intuitively, \aics has two ``good'' repairs. The first two rules state that $a$ or $b$ should be added in order to ``fix'' the violated constraint $\lnot (\lnot a \land \lnot b)$. 
 Depending on that choice, the last rule determines whether or not $c$ should be repaired.  The two intended repairs are thus $\{\add a,\add c\}$ and $\{\add b\}$. 
 Let us investigate what the different AFT-style semantics give in this case. 
 
 Consider 
\[\UUU_0: a\mapsto \lunkn, b\mapsto \lunkn, c\mapsto\lunkn.\]

Here, it holds that 
\begin{align*}
 \suppin_{\UUU_0}(a) &= \lunkn, & \suppout_{\UUU_0}(a) &=\lfalse \\
 \suppin_{\UUU_0}(b) &= \lunkn, & \suppout_{\UUU_0}(b) &=\lfalse \\
 \suppin_{\UUU_0}(c) &= \lunkn, & \suppout_{\UUU_0}(c) &=\lfalse 
\end{align*}
Hence, $\Ap(\UUU_0) = \UUU_0$ and $\UUU_0$ is the \Ap-Kripke-Kleene fixpoint. 
Furthermore, we claim that there are no unfoundedness refinements of $\UUU_0$ and hence that $\UUU_0$ is also the \Ap-well-founded fixpoint. To see that our claim indeed holds, notice that any unfoundedness refinement of $\UUU_0$ should consist of making a subset of $U$ of $\{a,b,c\}$ false, in such a way that for each $u\in U$, $\Ap(\UUU_0[U: \lfalse])(u)=\lfalse$. 
Assume $a\in U$. In order for $\Ap(\UUU_0[U: \lfalse])(a)$ to be false $b$ must be $\ltrue$ in $\UUU_0[U: \lfalse]$ (otherwise the body of the rule defining $\add a$ is unknown or true). That is not possible, hence $a\not \in U$. From a similar argument, we find that $b\not \in U$ and $c\not \in U$. 
Trivially, the two intended repairs are more precise than the well-founded fixpoint. 

Now, let us check whether $\UU := \{\add a, \add c\}$ is a stable fixpoint. 
For this, we need to verify if 
\[\UU =\lfp(\Ap(\cdot,\UU)_1).\]
Define $\UU_0=\emptyset$. Then 
\[(\UU_0,\UU) = a \mapsto \lunkn, b\mapsto \lfalse, c\mapsto \lunkn.\]
Hence 
\[\Ap(\UU_0,\UU) = a \mapsto \ltrue, b\mapsto \lunkn, c \mapsto \lunkn\]
and 
\[\UU_1 := \Ap(\UU_0,\UU)_1 = \{a\}.\]
Similarly, 
\[(\UU_1,\UU) = a \mapsto \ltrue, b\mapsto \lfalse, c\mapsto \lunkn.\]
Hence 
\[\Ap(\UU_1,\UU) = a \mapsto \ltrue, b\mapsto \lfalse, c \mapsto \lunkn\]
and 
\[\UU_2 := \Ap(\UU_1,\UU)_1 = \UU.\]
Furthermore, $\Ap(\UU_2,\UU) = \UU_2=\UU$, hence  we find that indeed, \UU is an \Ap-stable fixpoint. 
The case for $\{\add b\}$ is similar. 

It can also be verified that there are no other $\Ap$-stable fixpoints. Due to minimality, no other could contain $b$, hence they must be subsets of $\{a,c\}$. Again, due to minimality, the only such subset is \UU.
\end{example}

Hence, in the above example, \Ap-stable repairs capture the intended semantics.

\paragraph{Properties of AFT-Style Semantics}%
% \todo{start new section here?}
% \luis{If we have results about justified repairs, it might make sense to include remarks on whether they hold in the non-normal case. If we do that, we need to revise this sentence (refers to some sentence in intro).}
% \bart{The problem is that the AFT semantics are not defined for non-deterministic operators, so we won't be able to derive much useful stuff from there I'm afraid}
% \luis{We can always define stuff in general via normalization. Since justified repairs don't work well with normalization, this means that the relationships need to be analyzed again. For example, does Proposition 3.13 hold if we start with non-normal AICs, and consider stable repairs after normalization vs justified repairs without normalizing?}
% \bart{Hmmm... I Don't immediately have the answer to that one... Don't have any intuitions either. }
% 
% \luis{probably we'll ignore the whole discussion above}

We now show that all of these semantics are nicely invariant under shifting. 
\begin{proposition}
 \Ap, and hence also \Op, is invariant under shifting, i.e., for each set $S\subseteq \atoms$:
 \[\Apfull = \threeap_{\langle\shift_S(\db),\shift_S(\eta)\rangle}\]
\end{proposition}
\begin{proof}
First note that for each update action $u$, $u$ changes $\db$ iff $\shift_S(u)$ changes $\shift_S(\db)$. Hence for each atom $\change_{\db} a = \change_{\shift_S(\db)} a$ and thus
$\overline{\UU}=\overline{\shift_S(\UU)}$ 
(where the first identification is with respect to \db and the second with respect to $\shift_S(\db)$. 
Since \Ap is defined entirely in terms of these sets, the result follows. 
% \bart{Proof is still a bit of handwaving if you ask me. Could probably be more formalised}
% \luis{I'm ok with it :-) I don't see that we gain a lot by adding a formal proof.}
% \luis{I was rereading Caroprese's work, and they talk about shifting in their 2011 paper (Theorem 20). This also allows us to handwave a bit, I guess.  As an alternative, we can prove the theorem formally using the lemmas they have in the Appendix.}
\end{proof}

\begin{corollary}
 All AFT-style semantics for AICs have the shifting property. 
\end{corollary}

\begin{proposition}\label{prop:wf-wf}
 If the AFT-well-founded repair is two-valued,  it is also well-founded (as defined by \citet{tase/Cruz-FilipeEGN13}). 
\end{proposition}
\begin{proof}
Let $\left(\UUU_i\right)_{i\leq k}$ be a well-founded induction of \Ap. 
For each $i$, define $\UU_i$ as $\{a \in \atoms \mid \UUU_i=\ltrue\}$. 
We will prove the following claim by induction on the length $k$ of the well-founded induction (note that we restrict to finite well-founded inductions here, since we assume $\atoms$ to be finite). 

There exists a sequence $\alpha_1,\dots,\alpha_n$ such that $\UU_k=\{\alpha_1,\dots,\alpha_n\}$ and, for each $i\in\{1,\dots,n\}$, there is a rule $r_i$ such that $\{\alpha_1,\dots,\alpha_{i-1}\}(\db) \models \body (r_i)$ and $\alpha_i = \head(r_i)$.

From this claim, taking any terminal well-founded induction yields the desired result. 

We now show the claim indeed holds. 
The claim is trivial for $k=0$. Assume the claim holds for $k$, we show that it also holds for $k+1$. 
Thus assume $\alpha_1,\dots,\alpha_n$ is a sequence with $\UU_{k} = \{ \alpha_1,\dots,\alpha_n\}$ satisfying the above condition. 
If $\UUU_{k+1}$ is an unfoundedness refinement of $\UUU_k$, then $\UU_{k+1}=\UU_k$ and there is nothing to show. Hence, assume that $\UUU_k \leqp \UUU_{k+1}\leqp \Ap(\UUU_k)$. In this case, $\UU_{k+1} = \UU_k \cup \{ b_j\mid 1\leq j\leq m\}$ for some sequence of elements $b_j$ such that $\Ap(\UUU_k)(b_j) = \ltrue$. For each $j$, let $\UU'_j$ denote $\{\alpha_1,\dots,\alpha_n,\beta_1,\dots,\beta_j\}$. 
We claim that the sequence 
$\alpha_1,\dots,\alpha_n,\beta_1,\dots,\beta_m$ still satisfies the condition in the claim. 
To see this, note that from the definition of $\Ap$, it follows that for each $j\in \{1,\dots, m\}$ there is a rule $r_j$ with $\nup(r)^{\UUU_k(\db)}=\ltrue$ and $\head(r_j)=b_j$. Furthermore, for each $j$ it holds that $\UU_{j-1}' \geqp \UUU_k$ hence also $\nup(r)^{\UU_{j-1}'}$. Since $b_j\not \in \UU_{j-1}$, we also see that $\body(r_j)^{\UU_{j-1}'} = \ltrue$. Hence, the claim indeed follows for $\beta+1$ as well. 
% 
% 
% 
% $\alpha_1,\dots,\alpha_n$ such that $\UU=\{\alpha_1,\dots,\alpha_n\}$ and, for each $i\in\{1,\dots,n\}$, there is a rule $r_i$ such that $U_{i-1}(\db) \models \body (r_i)$ and $\alpha_i \in \head(r_i)$, where $U_{i-1} = \{\alpha_1,\dots,\alpha_{i-1}\}$.
% 
% 
%  \todo{idea of the proof. 
%  
%  Take a well-founded induction $\left(\UUU_i\right)_{i\leq \beta}$. For each $i$, define $\UU_i$ as equal to $\UUU_i$ except that everything unknown in $\UUU_i$ is interpreted as $\lfalse$ in $\UU_i$. It is clear that $\UUU_i\leqp\UU_i$ in this case. 
%  Now, the claim is that $\UU_i$ and $\UU_{i+1}$ differ only in a set of atoms that have at least one rule body satisfied in $\UU_i$. Furthermore, that body remains satisfied if we add them one by one. To see this, for any set $\UU$ such that $\UU_i\subseteq \UU \subseteq \UU_{i+1}$, it also holds that $\UU\geqp \UUU_i$. For each atom derived in $\UUU_{i+1}$, there is a rule $r$ with $\nup(r)^{\UUU_i}=\ltrue$ and $\head(r)=a$. Since truth evaluation is $\leqp$-monotone, it also holds that $\nup(r)^{\UU} = \ltrue$. Hence, we can add those atoms one by one (TODO: make this more formal: explicitly construct the sequence). }
%  
\end{proof}

\begin{example}\label{ex:wf:wf}The converse of Proposition \ref{prop:wf-wf} does
not hold. Consider for instance the following set $\aics$ of AICs 
   \begin{align*}
  \lnot a &\aicrule \add a \\
  \lnot a\land \lnot b &\aicrule \add b\\
  \lnot b \land \lnot c &\aicrule \add  c
 \end{align*}
 and $\db=\emptyset$.
 In this case, the AFT-well-founded repair is $\UU_{AFT}: a \mapsto \ltrue, b\mapsto \lfalse, c\mapsto \ltrue$. This is clearly the intended repair. Indeed, the first rule dictates that $a$ needs to be changed (here: added) no matter what. The second rule then becomes void (there is never a reason to add $b$) and the last rule dictates that also $c$ must be added. 
 However, $a \mapsto \ltrue, b\mapsto \ltrue, c\mapsto \lfalse$ is also a well-founded repair, obtained by first applying the second rule and then the first one.
\end{example}
% \luis{We might say that this example is from \cite{iclp/Cruz-Filipe16}; otherwise it looks weird that $DB\neq\emptyset$ as in all other examples.}

% \todo{check the link between ``justified repair'' and ``stable repair''. My feeling is that they should be very closely related. For instance in Example 20 in the GF and AIC paper, this is a case where stable coincides with justified. However, there is also a notion of ultimate stable repair (which coincides here with grounded). This is similar to logic programming, where 
% \begin{align*}
%  a &\lrule b.\\
%  a &\lrule \lnot b.\\
% b &\lrule a.
% \end{align*}
% does not have $\{a,b\}$ as a stable model, but does have it as an ultimate stable model. 
% 
% 
% More explanation why I feel these two are related. The definition of justified repair works as follows. First, fix all no-effect actions. Those are the things you \emph{do not change}. Then, the condition is that we have a minimal model that has at least those actions. 
% This is very similar to the notions of a reduct in logic programming: first fix the negative atoms (to get a reduct), then consider minimal models of the reduct. 
% }

\begin{proposition}\label{prop:stable_is_justified}
All \Ap-stable repairs are justified. 
\end{proposition}
\begin{proof}
We can safely assume that \UU is a repair of \db (otherwise, it is not a $\Ap$-stable repair).

 Before starting the actual proof, we introduce a couple of auxiliary operators. 
 For each set of update actions $\VV$, let $\ext(\VV)$ denote $\VV\cup \neff_\UU(\db)$.
 %Notice that even if $\VV$ is consistent, $\ext(\VV)$ can be inconsistent. 
 %However, whenever $\VV \subseteq \UU$, $\ext(\VV)$ is consistent. 
 Note that $\ext(\VV)$ is consistent whenever $\VV\subseteq\UU$.
 For each set of update actions $\VV$, let $\closure(\VV)$ denote \[\closure(\VV)= \VV\cup \{\head(r) \mid \actof(\nup(r)) \subseteq \VV\}.\] 
%  \todo{maybe closure should be defined differently: probably we need to drop teh \VV}
 Now, we define the operator (on sets of update actions):
\[O: \VV \mapsto \closure(\ext(\VV)) \setminus \neff_\UU(\db).\]
Below, we prove the following claims:
\begin{compactdesc}
 \item \textbf{Claim 1}: \UU is a minimal prefixpoint of $O$ if and only if $\UU$ is a justified repair of \fulldb. 
 \item \textbf{Claim 2}: For any literal $l$, $\actof(l)\in \ext(\db)$ if and only if $l^{(\overline \VV, \overline \UU)(\db)} = \ltrue$. 
 \item \textbf{Claim 3}: For any update action $\alpha$, $\alpha\in \closure(\ext(\VV))$ if and only if  $\supp_{(\overline\VV,\overline\UU)(\db),\aics}(\alpha) = \ltrue$. 
 \item \textbf{Claim 4}: For every set of update actions $\VV\subseteq \UU$: 
 \[\Ap(\overline\VV,\overline\UU)_1\subseteq \overline{O(\VV)}.\] 
\end{compactdesc}
Now, assume $\UU$ is a $\Ap$-stable repair. It is clear that $O$ is a monotone operator, hence it has a unique minimal prefixpoint, which is also its least fixpoint. Since $\UU$ is a repair, it is a fixpoint of $O$; we need to show that it is minimal. Assume $\UU'\subseteq \UU$ is a prefixpoint of $O$ as well. This means $O(\UU')\subseteq \UU'$ 
and hence 
\[\Ap(\overline{\UU'},\overline\UU)_1 \subseteq \overline{(O(\UU'))}\subseteq \overline{\UU'},\]
i.e., $\overline{\UU'}$ is a prefixpoint of $\Ap(\cdot,\overline\UU)_1$. 
Since $\overline\UU$ is an $\Ap$-stable repair, $\overline\UU$ is the least prefixpoint of $\Ap(\cdot,\overline\UU)_1$ and thus $\overline\UU = \overline{\UU'}$. Hence, also $\UU=\UU'$, which we needed to prove. We conclude that, indeed, $\UU$ is a justified repair. 


% 
% From Claim 4, it follows that this least fixpoint must thus also be the least fixpoint of $\Ap(\cdot,\overline\UU)_1$ (note that dropping the assumptions of consistency or of ``all actions should change \db'' never yields smaller fixpoints, since dropping one of these assumptions never adds subsets of this least fixpoint). 
% Hence, $\UU$ is a minimal prefixpoint of $O$ if and only if $\overline \UU$ is a stable fixpoint of $\Ap$. By Claim 1, we then find that our proposition indeed holds. 
% % 
% All that remains is to prove our claims. 

\textbf{Claim 1}
Recall that $\UU$ is a repair. 
% We already showed that $\UU$ is a repair. 
The claim then
%This
follows immediately from the definition of justified repair. Prefixpoints of the \closure operator are sets of update actions closed under \aics. Hence $\UU$ is a minimal prefixpoint of $O$ iff $\ext(\UU)$ is a minimal set of update actions that contains $\neff_{\UU}(\db)$ and is closed under $\aics$. 

%% \luis{Strictly speaking, this proves that $\UU$ is a minimal prefixpoint of $O$ iff $\ext(\UU)$ is a justified \emph{weak} repair. However, justified weak repairs are justified repairs when we worry about normal AICs. I think we should say this, but can't phrase it nicely.}
%% \bart{\UU IS a repair. That is established in the first sentence of the proof. So we proved what we claimed, no? (our claim is only claimed for sets that are repairs in the first place)}
%% \luis{Yes. I was referring to the sentence ``Hence\ldots''. What I'm missing is precisely the combination of that sentence with the fact that \UU is a repair, which was established previously (I was confused the first time I read the proof).}

\textbf{Claim 2} Pick some literal $l$ and assume that $l=a$ or $l=\lnot a$ for some atom $a\in \atoms$.

First assume that $\actof(l)\in\ext(\VV)=\VV\cup\neff_\UU(\db)$. We show that $l^{(\overline \VV, \overline \UU)(\db)} = \ltrue$. 
 We consider two cases:
\begin{itemize}
 \item If $\actof(l)\in \neff_\UU(\db)$, then $l^\db = \ltrue$ and $\UU$ does not change the value of $l$, hence $a\not\in\overline\UU$. Thus $(\overline \VV,\overline \UU)(a)=\lfalse$ and in this case $l^{(\overline \VV,\overline \UU)(\db)} = l^\db = \ltrue$. 
 \item If $\actof(l)\not\in \neff_\UU(\db)$, then it must hold that $\actof(l) \in \VV\subseteq \UU$. Since $\actof(l)\in \UU$ and every action in \UU changes \db, it must hold that $\lit^\db=\lfalse$. Now, since $\lit \in \VV$, $a\in \overline \VV$ and $(\overline \VV, \overline \UU) (a) = \ltrue$. Thus $\lit^{(\overline\VV,\overline\UU)(\db)} = (l^\db)^{-1} = \ltrue$ in this case. 
\end{itemize}
For the other direction, assume that $l^{(\overline \VV, \overline \UU)(\db)} = \ltrue$. We need to show that $\actof(l)\in\ext(\VV)=\VV\cup\neff_\UU(\db)$. Assume that $\actof(l)\not\in \neff_\UU(\db)$, we show that $\actof(l)\in \VV$. 
Since $l^{(\overline \VV, \overline \UU)(\db)} = \ltrue$ and $\overline\UU\geqp (\overline\VV,\overline\UU)$, also $l^\UU=\ltrue$. Since $l\not\in \neff_\UU(\db)$, this means that $l^\db=\lfalse$.
Now,
$l^{(\overline \VV, \overline \UU)(\db)} = \ltrue = (l^\db)^{-1}$. Hence it must hold that $(\overline \VV,\overline \UU)(a) = \ltrue$, i.e., that $a\in \overline \VV$. Since $\lit^\db = \lfalse$, this means that $  \actof{(\lit)}\in \VV$, which is exactly what we needed to prove. 


\textbf{Claim 3} 
Let $\alpha$ be an update action. 
It holds that  $\supp_{(\overline\VV,\overline\UU)(\db),\aics}(\alpha) = \ltrue$ if and only if there is some rule $r$ with $\head(r)=\alpha$ and $\nup(r)^{ (\overline\VV, \overline\UU)(\db)} = \ltrue$. This means that for each literal $l'\in \nup(r)$, $l'^{(\overline\VV, \overline\UU)(\db)} = \ltrue$. From Claim 2 it then follows that this is equivalent with the condition that each literal $l'\in\nup(r)$ is an element of   $\ext(\VV)$, i.e., with  the condition that $\alpha \in \closure(\ext(\VV))$. 


\textbf{Claim 4}
Take an atom $a$ and a set $\VV$ of update actions. It holds that $a\in \Ap(\overline\VV,\overline\UU)_1$ if and only if one of the following holds:
\begin{itemize}
 \item $(\overline \VV,\overline \UU)(a) = \lfalse$ and $\supp_{(\overline\VV,\overline\UU)(\db),\aics}(\change a)=\ltrue$
 \item $(\overline \VV,\overline \UU)(a) = \lunkn$, $ \supp_{(\overline\VV,\overline\UU)(\db),\aics}(\change a)=\ltrue$, and $\supp_{(\overline\VV,\overline\UU)(\db),\aics}(\change a^D) = \lfalse$.
\end{itemize}
In both cases, $\supp_{(\overline\VV,\overline\UU)(\db),\aics}(\change a)=\ltrue$, hence by Claim 3, $\change a\in \closure(\ext(\VV))$. Now if $\VV\subseteq \UU$, then $a\in\Ap(\overline\VV,\overline\UU)_1$ entails $a\in \overline\UU$, hence also $\change a \in \UU$ and thus $\change a \in \closure(\ext(\VV)) \cap \UU = O(\UU)$, which we needed to prove. \qedhere




% \todo{todo} Since we assumed that $\UU$ is a weak repair,  it follows easily that $\closure(\UU)=\UU$, that $\closure(\ext(\UU)) = \ext(\UU)$ and that $O(\UU) = \UU$. 
% Now, for a literal $a$, it holds that 
% 
% Take any $\VV\subseteq \UU$; it follow that every action in \VV changes \db and that \VV is consistent. 
% 
% Let $a$ be an update action. It hold that $a\in \closure(\ext(\VV))$ if and only if there is a rule $r$ with $\head(r)= a$ and $\actof(\nup(r))\subseteq \VV\cup\neff_\UU(\db)$
% 
% 
% 
% We first show that $O(\VV)\subseteq A(\overline\VV,\overline\UU)_1$.
% Take any action $a\in O(\VV)$
% 
% TODO: get to $a\in O(\VV)$ IFF $\suppin_\VV(a) = \ltrue$. 
% THen: we can't have both $a \in O(\VV)$ and $a^D\in O(\VV)$ since $O(\VV)\subseteq O(\UU) = \UU$ is consistent.
% 
% First notice that it follows easily from
%  
% %  $\actof(\nup(r))\subseteq \UU$ implies $\head(r)\cap \UU\neq \emptyset$
%  
%  
% 
% 
% 
% 
%  First assume $\UU$ is a justified repair. 
%  For each set of update actions $\UU'$, let $c(\UU')$ denote $\UU'\cup \neff_\UU(\db)$. 
%  Since $\UU$ is a justified repair, $s(\UU)$ is a justified action set. 
%  This means that 
%  
%  \todo{IDEA:
%  Consider the operator 
%  \[O: \UU'\mapsto close(c(\UU')) \setminus neff_\UU(\db)\]
%  My feeling is that $O= \Ap(\cdot,\UU)_1$
%  AND: that the condition ``justified repair'' can be rewritten to ``minimal prefixpoitn'' of $O$. In that case, since $O$ is monotone, we get that ``minimal prefixpoint'' coincides with least fixpoint. QED
%  (we will be using the fact the \aics is normal in the proof)
%  Be careful, this operator is not defined when $\UU'$ is inconsistent with $\neff$, however, it should suffice to have it defined when the union is consistent.
%  
%  
%  To see this, notice that NEFF = the stuff you don't change. In our representation of three-valued update sets, this EXACTLY corresponds to the upper bound}
%  
\end{proof}

\begin{example}\label{ex:justified_not_stable}
 The converse of Proposition \ref{prop:stable_is_justified} does not hold. Consider the following set \aics of AICs. 
 \begin{align*}
  \lnot a &\aicrule \add a \\
  a\land \lnot b &\aicrule \add b\\
  a \land \lnot b &\aicrule \remove a
 \end{align*}
 with $\db=\emptyset$. 
 In this case $\{\add a,\add b\}$ is a justified repair of \fulldb, but not a stable repair. 
 To see that it is not a stable repair, recall that we identify a partial action set with an element of $(2^{\atoms})^c$, e.g., $\{a\mapsto\lunkn,b\mapsto\lunkn\}$ is identified with $(\emptyset,\{a,b\})$. It now suffices to note that 
 \[
 \Ap(\emptyset,\{a,b\}) = (\emptyset,\{a,b\})
 \]
 and hence
 \[
 \lfp \Ap(\cdot,\{a,b\})_1 = \emptyset\neq \{a,b\}.\]
  
To see that it is a justified repair, note that $\{\add a,\add b\}$ is the least set closed under \aics. 
\end{example}

While the converse of Proposition \ref{prop:stable_is_justified} does not hold in general, for a broad class of active integrity constraints, it does hold. We first define this class and then prove that this is indeed the case. 

\begin{definition}
 A set of AICs \aics is called \emph{unipolar} if there are no rules $r,r'\in\aics$ with $\head(r)=\head(r')^D$. 
\end{definition}

Unipolar AICs make sense in practice, for example if there are tables from which removing data is never an option.


\begin{proposition}\label{prop:justified_is_stable_sometimes}
If \aics is unipolar, then each justified repair of \fulldb is \Ap-stable. 
\end{proposition}
\begin{proof}
 To prove this theorem, we show the following strengthening of \textbf{Claim 4} in the proof of Proposition \ref{prop:stable_is_justified}. 
 \begin{compactdesc}
  \item \textbf{Claim 4'}: For every set of update actions $\VV\subseteq \UU$: 
 \[\Ap(\overline\VV,\overline\UU)_1= \overline{O(\VV)}.\] 
\end{compactdesc}
 It then follows easily that $\UU$ is a minimal fixpoint of $O$ iff $\bar\UU$ is a minimal fixpoint of $\Ap(\overline\VV,\overline\UU)_1$ and the result follows from \textbf{Claim 1} in the proof of Proposition \ref{prop:stable_is_justified} and the definition of \Ap-stable fixpoint. 
 
\textbf{Claim 4'}
One direction of this claim has been proven as \textbf{Claim 4} in the proof of Proposition \ref{prop:stable_is_justified}; we show that the other inclusion also holds.
 Take an atom $a$ and a set $\VV\subseteq\UU$ of update actions such that $a\in \overline{O(\VV)}$; we show that $a\in\Ap(\overline\VV,\overline\UU)_1$. Since $a\in\overline{O(\VV)}$, it holds that $\change a\in \closure(\ext(\VV))$ and thus (by \textbf{Claim 3}) that $\suppin_{(\overline\VV,\overline\UU)(\db),\aics}(a)=\ltrue$. This means that there is at least one rule $r\in\aics$ with $\head(r)=\change a$. Since \aics is unipolar, there can be no rules $r'\in\aics$ with $\head(r') = (\change a)^D$ hence, it holds that $\suppout_{(\overline\VV,\overline\UU)(\db),\aics}(a)=\lfalse$. From the definition of $\Ap$, we then find that $\Ap(\overline\VV,\overline\UU)(a)=\ltrue$ and thus that  $a\in \Ap(\overline\VV,\overline\UU)_1$, which we needed to prove. 
\qedhere
\end{proof}

From Proposition~\ref{prop:justified}, which states that all justified repairs are grounded, we easily find how justified repairs and the AFT-well-founded repair relate. 

% \begin{proposition}[Lemma 19 of \citet{iclp/Cruz-Filipe16}]
%  All justified repairs are grounded.
% \end{proposition}



\begin{corollary}
 The AFT-well-founded repair and the Kripke-Kleene repair approximate all justified repairs. 
\end{corollary}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../AFT-semantics-AIC.tex"
%%% End:
