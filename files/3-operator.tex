In this section we show how a set of normal AICs induces an operator on a suitably defined lattice.

% \subsection{The opera	tor $\Op$}

Given a fixed database $\db$, we are interested in the sets of update actions $\UU$ such that:
\begin{enumerate}
\item \UU is consistent and 
\item each action in \UU modifies \db.
\end{enumerate}
If $a\in \atoms$ and $\db$ is a database, we define $\change a$ to be the update action $\add a$ if $a\not\in \db$ and $\remove a$ if $a \in \db$.
This establishes a bijection between the sets of update actions satisfying the above two conditions and subsets of $\atoms$, where a set of atoms $\overline\UU\subseteq\atoms$ is identified with the set 
\[\UU = \{\change a\mid a \in \overline \UU \}\]
of update actions.
When no ambiguity arises, we omit the bar, and simply write $\UU$ for the subset of \atoms as well.
Only in places where the distinction between the two is essential (in technical parts of proofs) do we explicitly write $\overline\UU$.

Following the principle of minimality of change~\cite{Winslett90,ai/EiterG92}, we also typically prefer smaller sets of updates over larger sets.
Therefore, we are interested in the lattice $\langle 2^{\atoms},\subseteq\rangle$, where smaller elements correspond to better repairs according to this principle.

The intuitive reading of an AIC $r$ naturally suggests an operator over this lattice, defined as ``if $\UU(\db)\models\body(r)$ holds, then add $\head(r)$ to $\UU$''.
However, this definition quickly leads to inconsistent sets of update actions upon iteration, which we want to avoid.
We therefore propose a slight variant of this intuition, using the following concept.

\begin{definition}
  Let $\UU_1$ and $\UU_2$ be consistent sets of update actions over a set of atoms $\atoms$.
  The set $\UU_1\uplus\UU_2$ is defined as
  \[\UU_1\uplus\UU_2 = (\UU_1\cup\{\alpha\in\UU_2\mid\alpha^D\not\in\UU_1\})\setminus\{\alpha\in\UU_1\mid\alpha^D\in\UU_2\}\,.\]
\end{definition}
This operation models sequential composition of repairs in the following sense: given a database $\db$, if every action in $\UU_1$ changes $\db$ and every action in $\UU_2$ changes $\UU_1(\db)$, then $(\UU_1\uplus\UU_2)(\db)=\UU_2(\UU_1(\db))$.
In this case, we also have the relation
\[\left(\UU_1\uplus \UU_2\right)(\db) = \left(\UU_1\cup \UU_2\right) \setminus \{\alpha \mid \alpha,\alpha^D\in \UU_1\cup\UU_2\}\,.\]
Furthermore, if $\UU_1$ and $\UU_2$ are both consistent, then so is $\UU_1\uplus\UU_2$.

\begin{definition}
  Let $\db$ be a database and $\eta$ be a set of AICs over $\db$.
  The operator $\Op^\db:2^\atoms\to 2^\atoms$ is defined as follows:
  \[
    \Op^\db(\UU) = \UU\uplus\{\head(r)\mid \UU(\db)\models\body(r)\}
  \]
\end{definition}
In other words, $\Op^\db(\UU)$ is obtained by updating $\UU$ with the heads of all AICs whose bodies are satisfied by $\UU(\db)$.
The resulting set may contain less update actions than the number of such rules, since different AICs may include the same action in their heads.

\luis{There was a comment about defining this with $\nup(r)$ instead. I'm not sure this is correct.}

\begin{example}[Example \ref{ex:repairs} continued]
  Consider again the set of AICs $\eta$ from Example~\ref{ex:repairs}, where
  $\db=\{a,b\}$.
  Then $\Op(\emptyset)=\{\remove a, \remove b\}$. Indeed, the bodies of all rules are satisfied; hence all heads are ``added'' to $\emptyset$. 
\end{example}

The syntactic restrictions on AICs guarantee that the set $\Op^\db(\UU)$ is always consistent: if $\{+a,-a\}\subseteq\Op^\db(\UU)$, then there must be rules $r_1$ and $r_2$ such that $\neg a\in\body(r_1)$ and $a\in\body(r_2)$ with $\UU(\db)\models\body(r_i)$ for $i=1,2$, which is impossible.
In the interest of legibility, we write simply $\Op$ instead of $\Op^\db$ whenever $\db$ is clear from the context.

The operator $\Op$ provides alternative characterizations of the notions of weak repair, repair, founded, well-founded and grounded sets of update actions.

\begin{lemma}
  \label{lem:weak-repair}
  Let $\db$ be a database, $\eta$ be a set of normal AICs over $\db$ and $\UU$ be a set of update actions.
  Then $\UU$ is a weak repair for $\fulldb$ if and only if $\UU$ is a fixpoint of $\Op$.
\end{lemma}
\begin{proof}
  If $\UU$ is a weak repair for $\fulldb$, then $\UU(\db)\not\models\body(r)$ for all $r\in\eta$, whence $\Op(\UU)=\UU$.
  If $\UU$ is not a weak repair for $\fulldb$, then $\UU(\db)\models\body(r)$ for some $r\in\eta$, and $\Op(\UU)$ differs from $\UU$ by (at least) $\head(r)$.
\end{proof}

\begin{lemma}
  \label{lem:repair}
  Let $\db$ be a database, $\eta$ be a set of normal AICs over $\db$ and $\UU$ be a set of update actions.
  Then $\UU$ is a repair for $\fulldb$ if and only if $\UU$ is a minimal fixpoint of $\Op$.
\end{lemma}
\begin{proof}
  Follows directly from Lemma~\ref{lem:weak-repair} and the definition of repair.
\end{proof}

\begin{lemma}
  \label{lem:founded-char}
  Let $\db$ be a database, $\eta$ be a set of normal AICs over $\db$ and $\UU$ be a consistent set of update actions.
  Then $\UU$ is founded with respect to $\fulldb$ if and only if, for all $\alpha\in\UU$, it is the case that $\alpha\in\Op(\UU\setminus\{\alpha\})$.
\end{lemma}
\begin{proof}
  An action $\alpha\in\UU$ is founded if and only if there is a rule $r\in\eta$ such that $\UU(\db)\models\body(r)\setminus\{\alpha^D\}$.
  This is equivalent to saying that $(\UU\setminus\{\alpha\})(\db)\models\body(r)$.
  But, by definition of $\Op$, we have $\alpha\in\Op(\UU\setminus\{\alpha\})$ if and only if there is a rule $r\in\eta$ such that $(\UU\setminus\{\alpha\})(\db)\models\body(r)$, which concludes the proof.

  Consistency of $\UU$ is needed for the direct implication, as $\alpha$ is only added to $\UU\setminus\{\alpha\}$ by $\Op$ if that set does not already contain $\alpha^D$.
\end{proof} 

This result also gives some intuition regarding why founded repairs allow for circular dependencies: the definition of founded repair only checks that each individual action is supported by the remaining ones, but it allows for dependency cycles.

\begin{lemma}
  \label{lem:wf}
  Let $\db$ be a database, $\eta$ be a set of normal AICs over $\db$ and $\UU$ be a weak repair for $\fulldb$.
  Then $\UU$ is well-founded if and only if there is an ordering $\alpha_1,\ldots,\alpha_n$ of the elements of $\UU$ such that $\alpha_i\in\Op(\{\alpha_1,\ldots,\alpha_{i-1}\})$ for each $i=1,\ldots,n$.
\end{lemma}
\begin{proof}
  If $\UU$ is well-founded, then the ordering is given by the sequence of actions introduced at each node in the path, in the well-founded repair tree for $\fulldb$, going from the root to the node with label $\UU$.
  Conversely, if $\UU$ can be obtained in the manner described, then it defines a valid path in that same tree ending at a leaf.
\end{proof}



\begin{lemma}
 Let $\db$ be a database and $\eta$ a set of AICs over \db. A set of update actions $\UU$ is a grounded repair of \fulldb if and only if $\UU$ is a grounded fixpoint of \Op. 
\end{lemma}
\begin{proof}
Recall that grounded and strictly grounded fixpoints of \Op coincide.
We show that $\UU$ is a grounded repair of $\fulldb$ iff $\UU$ is a strictly grounded fixpoint of $\Op$.

First suppose
%\UU is a grounded repair of \fulldb. From Lemma \ref{lem:repair}, it follows that $\UU$ is a fixpoint of $\Op$. Suppose
that $\UU$ is not a strictly grounded fixpoint of \Op.
This means that there exists a set $\VV\subsetneq\UU$ such that $\Op(\VV)\cap\UU\subseteq\VV$.
From the definition of $\Op$ it follows immediately that, if $r$ is a rule such that $\VV(\db)\models\body(r)$, then $\head(r)\not\in(\UU\setminus\VV)$, whence $\UU$ is not a grounded repair for $\fulldb$.
 %This means that there exists a set of update actions $\VV$ such that $\Op(\UU\cap\VV) \subseteq\VV$ and $\UU \not \subseteq \VV$. 
%Taking $A=\UU\setminus V$, and $\UU'=\UU\setminus A$, we find that $\Op(\UU') \cap A = \emptyset$. This means (following the definition of \Op) that there is no rule whose body is satisfied  that derives an element of $A$ in $\UU'$.
% Since $\UU$ is a grounded repair, we arrive at a contradiction. 
 
Conversely, assume that $\UU$ is a strictly grounded fixpoint of \Op
% and let $A$ be any subset of $\UU$ such that no rule $r$ with $\head(r)\in A$ has $\body(r)$ satisfied in $\UU'=\UU\setminus A$. We should show that $A=\emptyset$. Now, from the definition of $\Op$, it follows that $\Op(\UU')\cap A=\emptyset$ and thus that $\Op(\UU') \cap \UU \subseteq \UU'$. Since groundedness and strict groundedness coincide, $\UU$ is strictly grounded and thus, $\UU'=\UU$ and $A=\emptyset$ indeed. 
and let $\VV$ be any subset of $\UU$ such that there is no rule $r$ for which $\VV(\db)\models\body(r)$ and $\head(r)\in(\UU\setminus\VV)$. From the definition of $\Op$, it follows that $\Op(\VV)\cap(\UU\setminus\VV)=\emptyset$ and thus that $\Op(\VV)\cap\UU\subseteq \VV$. Since $\UU$ is strictly grounded, it follows that $\VV=\UU$. 
\end{proof}

The previous lemma illustrates that Lemma \ref{lem:justified} is not a coincidence at all. 
Indeed, \mycitet{GroundedFixpoints} have already shown that all stable fixpoints of a given approximator are grounded, and 
\citet[Theorem~6]{tplp/CaropreseT11} showed that justified repairs are stable models of a given derived logic program. 
In the following sections, we explore this relationship further: first, we define an approximator for \Op and as such obtain also a notion of stable repair. 
Next, we will study the relationship between logic programs and AICs in depth. 

\luis{From the commented out stuff, I would include the sentence about avoiding circularity of support and the theorem on complexity. What do you think? I deleted the rest.}
\bart{Complexity comes later, together with the rest of complexity stuff}
\bart{Regarding the discussion of circularity of support. We do not give a formal definition of what this *actually* is. 
Our claim rests on the fact that ``no circularity of support'' would somehow coincide with ``grounded''. But this is hard to prove, given the lack of a definition of ``circularity''... }


\ignore{
The correspondence between justified repairs and answer sets for particular logic programs~\cite{Caroprese2011} shows that justified repairs can also be characterized in a related manner.
However, since answer sets of a logic program are models of its Gelfond--Lifschitz transform, the corresponding characterization in terms would be as fixpoints of the corresponding operator for a similarly derived set of AICs, rather than of $\Op$.

This result is not very surprising: justified weak repairs are answer sets of a particular logic program (Theorem 6 in~\cite{Caroprese2011}), and in turn answer sets of logic programs are grounded fixpoints of the consequence operator (see remark at the top of Section~5 in~\mycite{GroundedFixpoints}).
However, the translation defined in~\cite{Caroprese2011} is from logic programs to databases with AICs (rather than the other way around), so Lemma~\ref{lem:justified} is \emph{not} a direct consequence of those results.
Also, since grounded repairs can be built from the ground up, this result also establishes that justified repairs avoid circularity of support (a property that was claimed in~\cite{Caroprese2011}, but never formally discussed).


%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{theorem}
  \label{thm:grounded-complexity}
  Let $\db$ be a database and $\eta$ be a set of normal AICs over $\db$.
  The problem of deciding whether there exist grounded repairs for $\fulldb$ is $\Sigma^P_2$-complete.
\end{theorem}
\begin{proof}
  For membership, we need to show that we can decide the problem with a non-deterministic Turing machine with an NP oracle.
  Given a set of update actions $\UU$, checking that it is a fixpoint of $\Op$ can be done in polynomial time on the size of $\db$ and $\eta$; the NP-oracle can then answer whether there exists $\UU'\subsetneq\UU$ with $\Op(\UU')\cap\UU\subseteq\UU'$, thereby establishing whether $\UU$ is grounded.

  For hardness, we invoke the (polynomial time) translation $\mathit{aic}$ from logic programs to sets of AICs over the empty database given Section~7 of~\cite{Caroprese2011}.
  Given a logic program $\mathcal P$, deciding whether $\langle\emptyset,\mathit{aic}(\mathcal P)\rangle$ has a grounded repair is equivalent to deciding whether $\mathcal P$ has a grounded model, which is $\Sigma^P_2$-complete by Theorem~5.7 of~\mycite{GroundedFixpoints}.
\end{proof}

This result still holds if we allow a truly first-order syntax for AICs, where the atoms can include variables that are implictly universally quantified.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../AFT-semantics-AIC.tex"
%%% End:
}
