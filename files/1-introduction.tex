One of the key components of modern-day databases are integrity constraints: logical formulas that specify semantic relationships between the data being modeled that have to be satisfied at all times.
When the database is changed (typically by updating), it is necessary to check if its integrity constraints still hold; in the negative case, it must be repaired.

The problem of database repair has been an important topic of research for more than thirty years~\cite{icdt/Abiteboul88}.
There are two major problems when deciding how to repair an inconsistent database: \emph{finding} possible repairs and \emph{choosing} which one to apply.
Indeed, there are typically several ways to fix an inconsistent database, and several criteria to choose the ``best'' one have been proposed over the years.
Among the most widely accepted criteria are minimality of change~\cite{Winslett90,ai/EiterG92} -- change as little as possible -- and the common-sense law of inertia~\cite{PrzymusinskiT97} -- do not change anything unless there is a reason to do it.

A typical implementation of integrity constraints in database systems is by means of event-condition-action rules~\cite{TenienteO95,WidomC96}, which specify update actions to be performed when a particular event (a trigger) occurs and specific conditions hold.
However, these rules do not have a declarative semantics, making their joint behavior hard to understand.

The formalism of active integrity constraints (AICs) \cite{ppdp/FlescaGZ04} was inspired by a similar idea.
AICs express database dependencies through logic programming-style rules that include update actions in their heads.
They come with a set of declarative semantics~\cite{tplp/CaropreseT11} that identifies several progressively more restricted classes of repairs, which can be used as criteria to select a preferred repair.
These repairs can be computed directly by means of tree algorithms~\cite{tase/Cruz-FilipeEGN13}, which have been implemented as a prototype~\cite{CFHLNS15}.

%% Modern databases are often equipped with integrity constraints that specify which are valid states of the database. 
%% Sometimes, databases can reach states in which one of the integrity constraints is violated, for instance due to execution of some invalid update, due to merging two databases, ... 
%% In such case, one needs to repair the database \cite{ai/EiterG92}. 
%% The problem with this is that it is often unclear which repairs should be considered ``good repairs''. 
%% This is where active integrity constraints (AICs)  kick in \mycite{AIC} . 
%% The idea of AICs is that instead of simply specifying which properties a valid state of the database should adhere to, one also specifies how violation of these properties can be repaired. 
%% However, when there are multiple active integrity constraints present, there may be dependencies between them. 
%% For instance, certain ways of fixing one AIC might result in a state where another AIC is violated. 
%%
%% lcf: not sure what to include from this list of references
%% Defining a natural semantics for such AICs has been a topic of intensive research \cite{iclp/CaropreseGSZ06,sebd/MolinaroGC06,iclp/CaropreseTZ07,dasfaa/CaropreseGM07,iclp/CaropreseT08,tkde/CaropreseGZ09,tplp/CaropreseT11,iclp/Cruz-Filipe16}. 

It is striking that many intuitions about what ``good'' repairs are, such as minimality of change, are very similar to intuitions that surfaced in other domains of non-monotonic reasoning, such as logic programming \mycite{LP} and default logic \mycite{DL}. 
% For instance \todo{minimality} of change \cite{}, ... 
Still, it has been hard to find a satisfying set of semantics for AICs.
%\todo{list some problems.}
As shown by~\citet{tase/Cruz-FilipeEGN13}, the semantics of founded repairs~\cite{iclp/CaropreseGSZ06} unexpectedly fails to respect the common-sense law of inertia, while the more restricted semantics of justified repairs~\cite{tplp/CaropreseT11} forbids natural repairs in some cases.
That work proposed the operational semantics of well-founded repairs, which however is not modular~\cite{foiks/Cruz-Filipe14} and therefore severely restricted in its practical applicability.

% Essentially, fixing similar problems as in other NMR domains... 


In this paper\longpaper{\footnote{A previous version of this text has been published as \cite{}. This work extends the previous with proofs of all results, extra examples and an in-depth comparison with logic programming.}}, we transfer existing work from the field of non-monotonic reasoning to AICs. 
To this end, we define a new class of semantics for AICs that are natural counterparts of existing semantics in various non-monotonic reasoning domains. 
To be precise, we define semantics for AICs based on approximation fixpoint theory \cite{\refto{AFT}}, an abstract algebraic framework that unifies semantics of logic programming, default logic, autoepistemic logic \mycite{AEL}, abstract argumentation frameworks \cite{\refto{AF}} and abstract dialectical frameworks \mycite{ADF}, as shown by Denecker, Marek and Truszczy\'nski [\citeyear{DeneckerMT00,DeneckerMT03}] and \citet{journals/ai/Strass13}. 
In order to do so, we continue the work of \citet{iclp/Cruz-Filipe16}, who defined a semantic operator for AICs and used it to study the grounded fixpoint semantics \mycite{GroundedFixpoints} for AICs. 
In this paper, we define an approximating operator of Cruz-Filipe's semantic operator. 
When this operator is defined, approximation fixpoint theory immediately provides us with \begin{inparaenum} 
\item a supported fixpoint semantics, 
\item a well-founded fixpoint semantics, 
\item a (partial) stable fixpoint semantics, 
\item a Kripke-Kleene fixpoint semantics, and 
\item a (partial) grounded fixpoint semantics. %\bart{drop? non-classical} 
\end{inparaenum} 
We study properties of these new semantics and study how they compare to existing semantics. 
Furthermore, we argue that, from a practical point of view, the AFT-style well-founded semantics is very valuable. 
Indeed, we show that this semantics can be computed in polynomial time, and that, on a broad set of practical examples, it corresponds to the intuitions underlying database repairs,  providing natural upper and lower bounds on the set of acceptable repairs (formally: the AFT-style well-founded model approximates all justified, stable and grounded repairs).

Besides defining a new class of interesting semantics, our work provides solid foundations for transferring a rich body of work from the non-monotonic reasoning domain to AICs. For instance, we can now directly apply existing results from AFT, such as modularity results \cite{tocl/VennekensGD06,tocl/BogaertsVD16} or predicate introduction results \cite{VennekensMWD07a,VennekensMWD07b}. 
Following results from \citet{tplp/CaropreseT11}, our work also paves the way to applying AFT to revision programming. 
% To establish this relationship, we define a family of new semantics for AICs with some desirable properties:
% \begin{compactitem}
%  \item Each of our semantics satisfies the so-called \emph{shifting property} \cite{tcs/MarekT98}. 
%  \item The AFT-based well-founded semantics provides good over and under approximations of various other semantics, resulting in a computationally attractive method for reasoning approximately in one of these semantics. 
%  \item The AFT-based stable semantics is closely related to the grounded fixpoint semantics, but computationally more attractive.
% \end{compactitem}

% 
% Somewhere we should summarize our contributions:
% \begin{compactitem}
%  \item Our work provides better insights in the relationship between logic programming (or AEL, DL, ADF, AF) and AICs
% \item We define a new set of semantics with desirable properties:
% \begin{compactitem}
% \item  Shifting
%  \item WFF: good over and under approximation of what repairs should look like
%  \item WFF: allows us already to answer queries over the repaired database without computing (or deciding on) an actual repair. (not every query can be answered of course). 
%  \item WFF: polytime
%  \item SS: very close to grounded fixpoints, but computationally more attractive
% \end{compactitem}
% \item Our work opens the way to applying a rich algebraic theory to AICs: stratification and modularity results \cite{tocl/VennekensGD06,tocl/BogaertsVD16} and predicate introduction results \cite{VennekensMWD07a,VennekensMWD07b}. 
% \item Following results from \citet{tplp/CaropreseT11}, our work also opens the way to applying AFT to revision programming. 
% \end{compactitem}
%  


%\luis{Despite all the information in the background, I guess one can only understand this if one already knows something about AFT. We should state it explicitly in the beginning.}
%\bart{You mean in the beginning of the example or of the paper?}
%\luis{I guess in the beginning of the paper... just prepare people psychologically so that they won't be scared off too easily :-)}
